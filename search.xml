<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ABE-2EPSR</title>
    <url>/2021/04/10/ABE-2EPSR/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文主要介绍CP-ABE的两种具体实现，这个实现是在Waters大佬<sup><a href="ref1">1</a></sup>（你一定不陌生，因为前面谈到FIBE、KP-ABE还有CP-ABE都有他的身影）的论文里的。正如论文的标题描述的那样（An Expressive, Efficient, and Provably Secure Realization），这些实现都将线性秘密共享（LSSS）作为访问结构，进而依赖特定的难题，完成安全性的规约证明。<br><span id="more"></span><br>Waters论文中详细介绍了三种具体方案的构造，但是前两种被学者们“开发”的多，因此在这里着重介绍前两种。第一种基于Decisional q-PBDHE困难假设，第二种基于BDHE假设。无论是哪一种构造，方案的安全模型是和CP-ABE里边的安全模型是一样的。</p>
<h4 id="第一种构造"><a href="#第一种构造" class="headerlink" title="第一种构造"></a>第一种构造</h4><h5 id="Decisional-q-PBDHE-Assumption"><a href="#Decisional-q-PBDHE-Assumption" class="headerlink" title="Decisional q-PBDHE Assumption"></a>Decisional q-PBDHE Assumption</h5><p>判定型q-PBDHE假设描述为：选择一个乘法循环群 $\mathbb{G}_1$，阶数为$p$（$p$的选择依赖于具体方案的安全参数），令$a,s, b_1, …, b_q \in \mathbb{Z}_p$随机选取，$g$为群$\mathbb{G}_1$的生成元，如果攻击者获得向量$\overrightarrow{y} =$</p>
<script type="math/tex; mode=display">
\begin{align}
&g,g^s,g^a,...,g^{a^q},,g^{a^{q+2}},...,g^{a^{2q}} \nonumber \\
&\forall_{1\leq j\leq q}  g^{sb_j},g^{a/b_j},...,g^{a^q / b_j},,g^{a^{q+2} / b_j},...,g^{a^{2q} / b_j} \nonumber\\
&\forall_{1<\leq j,k\leq q,k\neq j} g^{a \cdot s \cdot b_k / b_j}, ..., g^{a^q \cdot s \cdot b_k / b_j} \nonumber
\end{align}</script><p>那么他分辨$e(g,g)^{a^{q+1}s} \in \mathbb{G}_2$和$ \mathbb{G}_2$上的一个随机元素$R$是困难的。<br>论文中定义攻击者决定$\mathbb{G}_1$上的q-PBDHE困难问题的优势为：</p>
<script type="math/tex; mode=display">
|Pr[\mathcal{B}(\overrightarrow{y},T=e(g,g)^{a^{q+1}s})=0]-Pr[\mathcal{B}(\overrightarrow{y},T=R)=0]|</script><p>注意这个地方定义的优势和前面FIBE以及CP-ABE中的优势不一样，但是描述的本质是一样的。</p>
<h5 id="方案的具体构造"><a href="#方案的具体构造" class="headerlink" title="方案的具体构造"></a>方案的具体构造</h5><h6 id="Setup-U"><a href="#Setup-U" class="headerlink" title="Setup($U$)"></a><strong>Setup($U$)</strong></h6><p>算法输入系统的总属性个数$U$，然后生成系统参数，包括阶数为$p$的乘法循环群$\mathbb{G}_1$，生成元$g$。然后随机生成$U$个与系统属性有关的元素$h_1,…,h_U \in \mathbb{G}_1$，此外，选择两个指数$\alpha ,a \in \mathbb{Z}_p$。<br>系统的公开参数为</p>
<script type="math/tex; mode=display">
PK=(g,e(g,g)^\alpha ,g^a,h_1,...,h_U)</script><p>系统的主密钥为$MSK=g^ \alpha$。</p>
<h6 id="Encrypt-PK-M-rho-mathcal-M"><a href="#Encrypt-PK-M-rho-mathcal-M" class="headerlink" title="Encrypt($PK,(M, \rho) ,\mathcal{M}$)"></a><strong>Encrypt($PK,(M, \rho) ,\mathcal{M}$)</strong></h6><p>加密算法将$PK$和消息$\mathcal{M}$作为输入。首先选择一个线性秘密共享方案的访问结构$(M, \rho)$，函数$\rho$将矩阵$M \in \mathbb{Z}_p ^{l \times n}$的每一行映射到一个属性。<br>首先选择随机向量$\overrightarrow{v} = (s,y_2,…,y_n) \in \mathbb{Z}_p^n$，$y_2,…,y_n$的作用是来分享秘密值$s$。$\forall i \in \left\{1,2,…,l \right\}$，计算$\lambda _i = M_i\overrightarrow{v}$，其中$M_i$ 表示矩阵$M$的第$i$行。此外，随机选择$r_1,…,r_l \in \mathbb{Z}_p$，然后得到密文形式为：</p>
<script type="math/tex; mode=display">
CT=((M, \rho),\mathcal{M}e(g,g)^{\alpha s},C ^\prime = g^s,\forall i \in [l]:C_i=g^{a\lambda _i}h_{\rho(i)}^{-r_i},C_i^\prime = g^{r_i}).</script><h6 id="KeyGen-MSK-S"><a href="#KeyGen-MSK-S" class="headerlink" title="KeyGen($MSK, S$)"></a><strong>KeyGen($MSK, S$)</strong></h6><p>密钥生成算法将主密钥$MSK$和用户的属性集合$S$作为输入。算法随机选择$t \in \mathbb{Z}_p$，然后产生密钥为：</p>
<script type="math/tex; mode=display">
SK=(K=g^\alpha g^{at},L=g^t,\forall x \in S:K_x = h_x^t).</script><h6 id="Decrypt-CT-SK"><a href="#Decrypt-CT-SK" class="headerlink" title="Decrypt($CT,SK$)"></a><strong>Decrypt($CT,SK$)</strong></h6><p>解密算法将密文$CT$和密钥$SK$作为输入。如果密钥$SK$对应的属性集合$S$满足访问结构，则根据LSSS的线性重构的性质，可以得到一组常数$\left \{ \omega _i \in \mathbb{Z}_p \right \}_{i \in I}$，使得$\sum _{i \in I}\omega_i \lambda _i = s$，其中$I \subset  [l]$为$I=\left \{ i:\rho (i) \in S \right \}$，表示$S$和访问结构的属性交集。然后便可以通过如下方式解密：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&e(C^\prime,K)/( \prod _{i \in I} (e(C_i,L)e(D_i,K_{\rho(i)}))^{\omega _i})= \nonumber\\
&e(g,g)^{\alpha s}e(g,g)^{ast}/( \prod _{i \in I} e(g,g)^{ta\lambda _i \omega _i})=e(g,g)^{\alpha s} \nonumber
\end{aligned}</script><p>进而就能从$C$部件中恢复出明文$\mathcal{M}$。</p>
<h4 id="第二种构造"><a href="#第二种构造" class="headerlink" title="第二种构造"></a>第二种构造</h4><h5 id="Decisional-BDHE-Assumption"><a href="#Decisional-BDHE-Assumption" class="headerlink" title="Decisional BDHE Assumption"></a>Decisional BDHE Assumption</h5><p>判定型q-BDHE假设描述为：选择一个乘法循环群 $\mathbb{G}_1$，阶数为$p$（$p$的选择依赖于具体方案的安全参数），令$a,s \in \mathbb{Z}_p$随机选取，$g$为群$\mathbb{G}_1$的生成元，如果攻击者获得向量</p>
<script type="math/tex; mode=display">
\overrightarrow{y} =(g,g^{a^1}, ..., g^{a^q}, , g^{a^{q+2}}, ..., g^{a^{2q}}, g^s)</script><p>那么他分辨$e(g,g)^{a^{q+1}s} \in \mathbb{G}_2$和$ \mathbb{G}_2$上的一个随机元素$R$是困难的。<br>论文中定义攻击者决定$\mathbb{G}_1$上的q-BDHE困难问题的优势为：</p>
<script type="math/tex; mode=display">
|Pr[\mathcal{B}(\overrightarrow{y},T=e(g,g)^{a^{q+1}s})=0]-Pr[\mathcal{B}(\overrightarrow{y},T=R)=0]|</script><h5 id="方案的具体构造-1"><a href="#方案的具体构造-1" class="headerlink" title="方案的具体构造"></a>方案的具体构造</h5><h6 id="Setup-U-1"><a href="#Setup-U-1" class="headerlink" title="Setup($U$)"></a><strong>Setup($U$)</strong></h6><p>算法输入系统的总属性个数$U$，然后生成系统参数，包括阶数为$p$的乘法循环群$\mathbb{G}_1$，生成元$g$。然后随机生成$U$个与系统属性有关的元素$h_1,…,h_U \in \mathbb{G}_1$，此外，选择两个指数$\alpha ,a \in \mathbb{Z}_p$。<br>系统的公开参数为</p>
<script type="math/tex; mode=display">
PK=(g,e(g,g)^\alpha ,g^a,h_1,...,h_U)</script><p>系统的主密钥为$MSK=g^ \alpha$。</p>
<h6 id="Encrypt-PK-M-rho-mathcal-M-1"><a href="#Encrypt-PK-M-rho-mathcal-M-1" class="headerlink" title="Encrypt($PK,(M, \rho) ,\mathcal{M}$)"></a><strong>Encrypt($PK,(M, \rho) ,\mathcal{M}$)</strong></h6><p>加密算法将$PK$和消息$\mathcal{M}$作为输入。首先选择一个线性秘密共享方案的访问结构$(M, \rho)$，函数$\rho$将矩阵$M \in \mathbb{Z} _p^{l \times n}$的每一行映射到一个属性。<br>首先选择随机向量$\overrightarrow{v} = (s,y_2,…,y_n) \in \mathbb{Z}_p^n$，$y_2,…,y_n$的作用是来分享秘密值$s$。$\forall i \in \left\{1,2,…,l \right\}$，计算$\lambda _i = M_i\overrightarrow{v}$，其中$M_i$ 表示矩阵$M$的第$i$行。然后得到密文形式为：</p>
<script type="math/tex; mode=display">
CT=((M, \rho),C=\mathcal{M}e(g,g)^{\alpha s},C ^\prime = g^s,\forall i \in [l]:C_i=g^{a\lambda _i}h_{\rho(i)}^{-s}).</script><h6 id="KeyGen-MSK-S-1"><a href="#KeyGen-MSK-S-1" class="headerlink" title="KeyGen($MSK, S$)"></a><strong>KeyGen($MSK, S$)</strong></h6><p>密钥生成算法将主密钥$MSK$和用户的属性集合$S$作为输入。算法随机选择$t \in \mathbb{Z}_p$，然后产生密钥为：</p>
<script type="math/tex; mode=display">
SK=(K=g^\alpha g^{at},L=g^t,\forall x \in S:K_x = h_x^t).</script><h6 id="Decrypt-CT-SK-1"><a href="#Decrypt-CT-SK-1" class="headerlink" title="Decrypt($CT,SK$)"></a><strong>Decrypt($CT,SK$)</strong></h6><p>解密算法将密文$CT$和密钥$SK$作为输入。如果密钥$SK$对应的属性集合$S$满足访问结构，则根据LSSS的线性重构的性质，可以得到一组常数$\left \{ \omega _i \in \mathbb{Z}_p \right \}_{i \in I}$，使得$\sum _{i \in I}\omega_i \lambda _i = s$，其中$I \subset  [l]$为$I=\left \{ i:\rho (i) \in S \right \}$，表示$S$和访问结构的属性交集。然后便可以通过如下方式解密：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&e(C^\prime,K)/( \prod _{i \in I} (e(C_i,L)e(C^ \prime,K_{\rho(i)}))^{\omega _i})= \nonumber \\
&e(g,g)^{\alpha s}e(g,g)^{ast}/( \prod _{i \in I} e(g,g)^{ta\lambda _i \omega _i})=e(g,g)^{\alpha s} \nonumber
\end{aligned}</script><p>进而就能从$C$部件中恢复出明文$\mathcal{M}$。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从以上描述的两种构造方式来看，其访问结构均为线性秘密共享，初一看两个方案的整体差不多。就密文而言，第一种构造对于每个属性有两项，而第二种构造只有一项；就密钥而言，二者产生的是一样的。两种构造最大的差别就是基于的难题形式不同（本质上都是离散对数难题，Diffie-Hellman难题只是很多的变种）。由于第一种构造基于q-PBDHE假设，比较复杂，第二种构造基于q-BDHE，相对简单。这两种方案的构造为后面的ABE的构造带来启示，许多ABE方案都是在这两种方案上拓展的。此外，这两个方案还是仅仅针对基本的四个过程，后面的ABE方案会关注属性撤销、多个权威机构、防止共谋攻击等安全需求。ABE方案的设计能兼顾更多地安全需求自然是更好地，更符合现实场景，进而更实用。<br><span name="ref1">B. Waters, “Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization,” in <em>Proc. PKC’11</em>, 2011, pp. 53–70, Springer.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>访问结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hur1-ABE</title>
    <url>/2021/04/11/Hur1-ABE/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>前面多次提到了属性撤销和防止共谋攻击的概念，这两个安全需求在属性基加密方案的设计方面至关重要，必须得考虑到。为什么这么说呢？根据前面构造的CP-ABE方案的细节，我们知道一个用户的密钥和系统中的密文中都包含许多个部件，大致可分为两类，一类是与属性有关的，一类是与属性无关的。</p>
<span id="more"></span>
<p>用户的私钥是根据他所拥有的属性来生成并分发的，不是说属性基加密的解密条件是当且仅当用户的属性集合满足密文的访问策略吗？光凭借自己的属性无法达到条件，自然的想法是几个用户拿出自己的属性密钥拼凑试图解密密文，因为几个人的属性拼凑起来就有可能满足访问结构了。还有，用户所拥有的属性并不是一层不变的，可能某个时刻因某种原因，用户的某个属性不在拥有了，那么他还能拥有解密的能力吗？显然以上两种情况都是不允许解密的。下面给属性撤销和防止共谋攻击下定义。</p>
<ul>
<li>属性撤销：一个用户的某个属性撤销了，而该属性是密文中访问结构的关键属性，即该用户的属性集合不再满足访问结构，那么他原则上不能解密最新上传的密文。<ul>
<li>如果撤销的属性并不影响，即该用户的当前属性集合仍然满足访问结构的话，他仍可以解密。</li>
<li>该用户原来的密钥还是可以解密原来的密文，因为在撤销之前，他的属性集合是满足条件的。</li>
</ul>
</li>
<li>共谋攻击：多个实体本身不能单独解密密文，试图将各自的密钥结合起来以达到解密密文的目的。<ul>
<li>这里是用实体，因为在实际场景中除了用户之外，还有存储密文的云服务器、网络攻击者等其他实体。</li>
</ul>
</li>
</ul>
<p>本文主要介绍Hur和Noh的方案构造，之所以取名字为Hur1-ABE<sup><a href="ref1">1</a></sup>，是与Hur后来提出的Hur2-ABE<sup><a href="ref2">2</a></sup>相区别的，Hur2-ABE在后边会具体介绍。</p>
<h4 id="KEK树描述"><a href="#KEK树描述" class="headerlink" title="KEK树描述"></a>KEK树描述</h4><p>Hur1-ABE实现属性撤销的方式，是借助KEK树这一特殊结构，并将用户根据不同的属性创建属性群，然后针对每一个属性群，构造一颗KEK树。这个KEK树的结构主要作用是共享群密钥，从而相应地嵌入到密文密钥中，以便日后的属性撤销。那么我们来看一看KEK树是怎样的一种结构吧。</p>
<img src="/2021/04/11/Hur1-ABE/KEK_Tree.jpg" class title="KEK Tree">
<p>KEK树本质上是一颗二叉树，树的每一个叶子节点和一个用户相联系。树中的每一个节点$v_j$都有一个密钥更新密钥$KEK_j$，为了方案的理解，定义一些与之有关的概念。</p>
<ul>
<li>路径节点集合$path(y)$：描述的是叶子节点到根节点的路径节点的集合，比如$v_9$节点的路径节点$path(v_9)= \left\{v_4,v_2,v_1 \right \}$。</li>
<li>路径节点密钥$PK_i$：描述的是用户$u_i$对应的叶子节点$y$的路径节点KEK的集合，比如用户$u_2$的路径节点密钥$PK_2=\left \{ KEK4, KEK_2, KEK_1 \right \}$。</li>
</ul>
<p>若与树有关的属性群为$G_i$，则与该群有关的概念如下。</p>
<ul>
<li>最小覆盖集合$cover(G_i)$：描述的是树中最少的涵盖所有未撤销属性的用户的节点集合，假设上图中撤销用户为$\left \{u_6,u_8 \right\}$，则$cover(G_i)=\left\{ v_2,v_{12},v_{14}\right\}$。</li>
<li>最小覆盖密钥$KEK(G_i)$：描述的是最小覆盖集合$cover(G_i)$对应的密钥更新密钥，假设如上，则$KEK(G_i)=\left\{ KEK_2,KEK_{12},KEK_{14}\right \}$。</li>
</ul>
<h4 id="方案具体构造"><a href="#方案具体构造" class="headerlink" title="方案具体构造"></a>方案具体构造</h4><h5 id="System-Setup"><a href="#System-Setup" class="headerlink" title="System Setup"></a><strong>System Setup</strong></h5><p>在系统初始化阶段，可信机构（TA)选择双线性群$\mathbb{G}_0$，阶数为$p$，生成元为$g$。然后随机选择两个指数$\alpha ,\beta \in \mathbb{Z}_p$，系统公开参数为：</p>
<script type="math/tex; mode=display">
PK=\left ( \mathbb{G}_0,g,h=g^\beta ,e\left ( g,g \right )^\alpha  \right ).</script><p>主密钥为：$MK=\left ( \beta ,g^\alpha  \right )$。</p>
<h5 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key Generation"></a>Key Generation</h5><h6 id="属性密钥生成"><a href="#属性密钥生成" class="headerlink" title="属性密钥生成"></a>属性密钥生成</h6><p>给定一个用户的属性集合$\Lambda $，输出对应的密钥$SK$，具体如下：</p>
<p>TA针对每一个用户$u_t \in U$($U$为系统用户的集合)，随机选择$r \in \mathbb{Z}_p$，对于每一个属性$\forall \lambda _j \in \Lambda $， 随机选择$r_j \in \mathbb{Z}_p$，然后计算密钥如下：</p>
<script type="math/tex; mode=display">
SK_t=\left( D=g^{\left(\alpha +r \right)/\beta}, \forall j \in \Lambda : D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=g^{r_j} \right).</script><p>此阶段和CP-ABE里边的密钥生成过程是一致的。然后TA将相关的属性群信息$\left\{G_j:\lambda_j \in \Lambda \right\}$给云服务器CSP（存储密文的地方），比如说用户$u_1,u_2,u_3$的属性集合分别为$\left\{\lambda_1,\lambda_2,\lambda_3\right\}$，$\left\{\lambda_2,\lambda_3\right\}$和$\left\{\lambda_1,\lambda_3\right\}$，那么TA将$G_1=\left\{ u_1,u_3 \right\}$，$G_2=\left\{ u_1,u_2 \right\}$和$G_1=\left\{ u_1,u_2,u_3 \right\}$发送给CSP。</p>
<h6 id="CSP更新密钥"><a href="#CSP更新密钥" class="headerlink" title="CSP更新密钥"></a>CSP更新密钥</h6><p>然后CSP针对TA发送的每一个属性群构建KEK树，每一个用户被分配到一个叶子节点位置，树中的每一个节点$v_j$都有一个KEK密钥$KEK_j$。每一个用户$u_t \in  U$接收他的路径节点密钥，比如用户$u_2$的路径节点密钥为$PK_2=\left\{ KEK_9,KEK_4,KEK_2,KEK_1 \right\}$。</p>
<h5 id="Data-Outsourcing"><a href="#Data-Outsourcing" class="headerlink" title="Data Outsourcing"></a>Data Outsourcing</h5><p>数据拥有者定义一个访问结构$\mathcal{T}$（访问控制树形式），然后按如下方式进行加密：</p>
<p>针对树$\mathcal{T}$中的每一个节点$x$（包括联系属性的叶子节点），选择一个与之对应的多项式$q_x$。多项式$q_x$的的最高次数为$d_x=k_x-1$。</p>
<p>多项式的选取遵循由根节点到叶子节点（从上到下）的方式。从根节点$R$开始，选择秘密值$s \in \mathbb{Z}_p$，并设置$q_R \left(0 \right)=s$，然后随机选择其他项的次数。对于其他节点$x$，递归的设置$q_x \left( 0 \right) = q_{p\left(x \right)} \left(index\left(x \right) \right)$，至于$q_x$的其他系数随机选择。</p>
<p>记$Y$为树$\mathcal{T}$的叶子节点的集合，然后密文可以表示为：</p>
<script type="math/tex; mode=display">
CT=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},
C_y^\prime=H \left(\lambda_y \right) ^ {q_y \left( 0  \right )} \right).</script><p>其中，$\lambda_y$表示的是叶子节点$y$对应的属性，$H \left(\cdot \right)$表示将属性映射到$\mathbb{G}_0$。</p>
<p>此阶段和CP-ABE方案中的加密阶段一致。</p>
<h5 id="Data-Re-Encryption"><a href="#Data-Re-Encryption" class="headerlink" title="Data Re-Encryption"></a>Data Re-Encryption</h5><p>此阶段CSP将重加密密文$CT$，具体如下：</p>
<ul>
<li>对于访问结构中涉及到的属性群$\left\{ G_y:y \in Y \right\}$，CSP随机选择属性群密钥$K_{\lambda_y} \in \mathbb{Z}_p$，然后重加密$CT$进而产生$CT^\prime$。</li>
</ul>
<script type="math/tex; mode=display">
CT^\prime=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},C_y^\prime=\left(H \left(\lambda_y \right) ^ {q_y \left( 0  \right )} \right)^{K_{\lambda_y}}\right).</script><ul>
<li>对于每一个群$G_i$，计算得到其最小覆盖密钥$KEK(G_i)$。比如$G_i=\left\{ u_1,u_2,u_3,u_4,u_5,u_7 \right\}$，那么$KEK(G_i)=\left\{ KEK_2,KEK_{12},KEK_{14}\right \}$。</li>
<li>用所有的最小覆盖密钥加密该群的属性群密钥，即$\left\{E_K(K_{\lambda_y}) \right\}_{K \in KEK(G_y)}$（$E$为对称加密），然后所有的属性都是如此，公开此参数，即$Hdr=\left( \forall y \in Y:\left\{E_K(K_{\lambda_y}) \right\}_{K \in KEK(G_y)}\right)$。</li>
</ul>
<h5 id="Data-Decryption"><a href="#Data-Decryption" class="headerlink" title="Data Decryption"></a>Data Decryption</h5><p>密文的形式为：</p>
<script type="math/tex; mode=display">
CT^\prime=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},C_y^\prime=\left(H \left(\lambda_y \right) ^ {q_y \left( 0  \right )} \right)^{K_{\lambda_y}}\right).</script><p>密钥的形式为：</p>
<script type="math/tex; mode=display">
SK_t=\left( D=g^{\left(\alpha +r \right)/\beta}, \forall \lambda_j \in \Lambda : D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=g^{r_j} \right).</script><h6 id="属性群密钥解密"><a href="#属性群密钥解密" class="headerlink" title="属性群密钥解密"></a>属性群密钥解密</h6><p>当用户收到$Hdr$后，首先解密属性群密钥。如果用户$u_t$持有属性$\lambda_j$，那么他能解密$K_{\lambda_j}$，因为有且仅有一个$KEK \in KEK(G_j)\cap PK_t$，也就是说$Hdr$中含有诸多$K_{\lambda_j}$的密文（用不同的对称密钥加密），而$u_t$恰好有一把对称密钥可以解密。得到群密钥$K_{\lambda_j}$之后，用户$u_t$更新自己的私钥为：</p>
<script type="math/tex; mode=display">
SK_t=\left( D=g^{\left(\alpha +r \right)/\beta}, \forall \lambda_j \in \Lambda : D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=(g^{r_j})^{1/K_{\lambda_j}} \right).</script><h6 id="密文解密"><a href="#密文解密" class="headerlink" title="密文解密"></a>密文解密</h6><p>首先定义一个递归的函数$DecryptNode(CT^\prime,SK,x)$（由下到上）:</p>
<ul>
<li><p>如果$x$为叶子节点，记$i=\lambda_x$。</p>
<ul>
<li><p>若$i \in \Lambda$（用户拥有属性$i$），则</p>
<script type="math/tex; mode=display">
\begin{aligned}
&DecryptNode(CT,SK,x) = \frac{e(D_i, C_x)}{e(D_i^\prime , C_x^ \prime)}= \nonumber \\ &\frac{e(g^r \cdot H(x)^{r_i}, h^{q_x(0)})}{(e(g^{r_i})^{1/K_{\lambda_x}} , (H(i)^{q_x(0)})^{K_{\lambda_x}})} = e(g,g)^{rq_x(0)}. \nonumber
\end{aligned}</script></li>
<li><p>若$i \notin \Lambda$，则定义$DecryptNode(CT,SK,x) =\perp $。</p>
</li>
</ul>
</li>
<li><p>如果$x$为非叶子节点，则$DecryptNode(CT,SK,x)$的计算规则如下：</p>
<ul>
<li><p>对于$x$节点的所有孩子节点$z$，调用$F_z = DecryptNode(CT,SK,z)$函数，记$F_z \neq \perp $的所有节点的集合为$S^ \prime$，若$|S^ \prime|&lt;k_x$，则$DecryptNode(CT,SK,x) =\perp $。</p>
</li>
<li><p>相反的话，则选取$S^ \prime$集合中任意$k_x$个元素组成集合$S_x$，按如下方式计算$DecryptNode(CT,SK,x)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&F_z=\prod _{z \in S_x} F_z ^{\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g) ^ {rq_z(0)}) ^ {\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g) ^ {rq_{p(z)}(index(z))}) ^ {\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g)  ^ {r \cdot q_x(i) \cdot \Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=e(g,g)^{rq_x(0)}.\nonumber
\end{aligned}</script></li>
</ul>
</li>
</ul>
<p>从递归函数的形式上看，尽管叶子节点和非叶子节点的具体计算方式不一样，但是有着统一的形式，因此只要能够依次满足条件地计算出树中适当个数的节点秘密值，就可以解密根节点的秘密值。即当属性集合$S$满足访问结构$\mathcal{T}$，那么就可以解密得到:</p>
<script type="math/tex; mode=display">
A = DecryptNode(CT,SK,r)=e(g,g)^{rq_R(0)} = e(g,g)^{rs}.</script><p>最后即可解密成功：</p>
<script type="math/tex; mode=display">
\widetilde{C}/(e(C,D)/A) = \widetilde{C}/(e(h^s,g^{((\alpha + r)/\beta )})/e(g,g)^{rs}) = M.</script><h5 id="Attribute-Revocation"><a href="#Attribute-Revocation" class="headerlink" title="Attribute Revocation"></a>Attribute Revocation</h5><p>假设属性群$G_i$中有成员变动（某用户撤销了属性$\lambda_i$，则需要更新密文和密钥，具体如下：</p>
<ul>
<li>CSP随机选择一个秘密值$s^\prime \in \mathbb{Z}_p$，然后再随机选取一个不一样的群密钥$K_{\lambda_i}^\prime \in \mathbb{Z}_p$，然后重加密密文得到新密文：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
& CT^\prime=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha (s+s^\prime)},C=h^{s+s^\prime},C_i=g^{q_i \left(0 \right )+s^\prime},C_i^\prime=\left(H \left(\lambda_i \right) ^ {q_i \left( 0  \right )+s^\prime} \right)^{K_{\lambda_y}^\prime}, \nonumber \\
 \forall y \in Y\setminus \left\{i \right\}:C_y=g^{q_y \left(0 \right )+s^\prime},C_y^\prime=\left(H \left(\lambda_y \right) ^ {q_y \left( 0  \right )+s^\prime} \right)^{K_{\lambda_y}}\right). \nonumber
\end{aligned}</script><ul>
<li>由于群$G_i$中有成员变动，那么此时的最小覆盖密钥发生了改变，重新计算$KEK(G_i)$，然后更新$Hdr$为$Hdr=\left( \left\{E_K(K_{\lambda_i}^\prime) \right\}_{K \in KEK(G_i)}，\forall y \in Y:\left\{E_K(K_{\lambda_y}) \right\}_{K \in KEK(G_y)}\right)$。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Hur1-ABE首次提出属性群的概念，通过属性群借助KEK树的技巧完成属性的撤销。属性群的提出为属性的撤销机制开辟了道路，后续的ABE方案中有许多学者沿袭这一概念，从而衍生出不同的属性撤销方案，比如说接下来的Hur2-ABE方案等。然而方案并不能抵抗撤销用户与未撤销用户之间的共谋，这是因为属性群中对应的每个节点的节点密钥不变，而且CSP会根据用户所在的位置将其路径密钥发送给用户，如果用户将路径密钥给撤销用户，或者更直接一点，用户直接将解密的属性群密钥给撤销用户，这样一来，撤销用户还是可以自己更新到正确的密钥，从而解密最近的密文。</p>
<p><span name="ref1">J. Hur and D. K. Noh, “Attribute-based Access Control with Efficient Revocation in Data Outsourcing Systems,” IEEE Transactions on Parallel and Distributed Systems, vol. 22, no. 7, pp. 1214–1221, Jul. 2011.</span></p>
<p><span name="ref2">J. Hur, “Improving Security and Efficiency in Attribute-Based Data Sharing,” IEEE Transactions on Knowledge and Data Engineering, vol. 25, no. 10, pp. 2271-2282, Oct. 2013.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>属性撤销</tag>
        <tag>共谋攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>DAC-MACS</title>
    <url>/2021/04/15/DAC-MACS/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>前面介绍了ABE有关的大部分知识，包括访问结构、密钥托管、属性撤销、共谋攻击、外包解密等诸多方面，今天要介绍的这篇论文是经典的ABE构造，方案简称为DAC-MACS<sup><a href="ref1">1</a></sup>，由Yang等人构造。方案中融合了几乎所有前面讲到的这些方面的内容，属于Chase<sup><a href="ref2">2</a></sup>系列的多属性权威机构ABE，能实现属性撤销，能防止用户的共谋，能外包解密。DAC-MACS方案是基于Waters的ABE-2SPR<sup><a href="ref3">3</a></sup>的第一种构造，因此是构建在Decisional q-PBDHE难题之上，运用了Green<sup><a href="ref4">4</a></sup>的外包解密技巧，可以说是经典的多属性权威ABE方案。下面我们来一睹DAC-MACS的内部构造吧！</p>
<span id="more"></span>
<h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><p>DAC-MACS方案中涉及五类实体，分别为全局证书机构（CA）、属性权威机构（AAs)、云服务器（CSP）、数据拥有者（DO）和数据消费者（DU）。</p>
<ul>
<li><p>CA：系统中全局可信的证书机构，针对每一个合法用户，CA分配一个全局唯一的用户身份，并为其生成全局公私钥对。CA不参与任何属性的管理，这意味着它并不为DU生成属性密钥。</p>
</li>
<li><p>AA：每一个AA都是一个独立的属性权威机构，负责产生、撤销以及更新用户的属性（只要用户的该属性由它所管理）。每个AA会为其管理的每一个属性生成系统的属性公钥，并为用户生成属性密钥。</p>
</li>
<li>CSP：存储DO的加密的密文的地方，也为用户生成解密令牌，如果存在属性撤销，则辅助更新密文到系统的最新版本。</li>
<li>DO：需要存储数据到CSP的用户。</li>
<li>DU：需要从CSP获取数据的用户。</li>
</ul>
<h4 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h4><ul>
<li><p>CA：完全可信的，但是不允许解密任何密文。</p>
</li>
<li><p>AA：可信的，但是可以被攻击者攻击“腐败”。</p>
</li>
<li>CSP：半可信的（诚实且好奇），即CSP会诚实地执行系统中它所负责的工作，但是会对存储的密文产生好奇。</li>
<li>DU：非诚实的，存在共谋行为。</li>
<li>所有非撤销者：不将收到的密钥更新密钥与撤销用户共享。</li>
</ul>
<h4 id="具体构造"><a href="#具体构造" class="headerlink" title="具体构造"></a>具体构造</h4><h5 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h5><p>记$S_A$和$S_U$分别表示属性权威机构的集合和系统属性的集合，记$\mathbb{G}$和$\mathbb{G}_T$为两个阶数为$p$的乘法循环群，$e:\mathbb{G} \times \mathbb{G} \rightarrow \mathbb{G}_T$为双线性映射，$g$为$\mathbb{G}$的生成元。记$H:\left\{0,1 \right\}^+ \rightarrow \mathbb{G}$为哈希函数。</p>
<h6 id="CA-Setup"><a href="#CA-Setup" class="headerlink" title="CA Setup"></a>CA Setup</h6><p>CA首先产生一对签名和验证密钥$(sk_{CA}, vk_{CA})$，然后选择随机数$a \in \mathbb{Z}_p$作为系统的主密钥，计算系统参数为$SP=(g,g^a,\mathbb{G},\mathbb{G}_T,H)$。</p>
<ol>
<li>User Registration：每个用户需要向CA注册自己的信息，如果用户是系统的合法用户，则为该用户分配一个全局唯一的ID$uid$，生成全局公钥$GPK_{uid}=g^{u_{uid}}$和全局私钥$GSK_{uid}=z_{uid}$，其中$u_{uid},z_{uid} \in \mathbb{Z}_p$随机选取。CA随后产生该用户的证书$Cert(uid)$，其中包含$Sign_{sk_{CA}}(uid, u_{uid},g^{1/z_{uid}})$。最后CA将全局公私钥对$(GPK_{uid},GSK_{uid})$和证书$Cert(uid)$发送给用户$uid$。</li>
<li>AA Registration：每一个AA需要向CA注册自己的信息，如果AA是系统的合法机构，则为该AA分配一个全局唯一ID$aid$，然后将CA的验证密钥$vk_{CA}$和系统参数$SP$发送给AA。</li>
</ol>
<h6 id="AA-Setup"><a href="#AA-Setup" class="headerlink" title="AA Setup"></a>AA Setup</h6><p>每一个$AA_k(k \in S_A)$运行AA Setup步骤。记$S_{A_k}$表示$AA_k$所管理的属性的集合，$AA_k$选择三个随机数$\alpha_k, \beta_k, \gamma_k \in \mathbb{Z}_p$作为该机构的私钥，即$SK_k=(\alpha_k, \beta_k, \gamma_k)$。对于每一个属性$x_k \in S_{A_k}$，$AA_k$计算产生属性公钥$PK_{x_k}=(g^{v_{x_k}}H(x_k))^{\gamma_k}$，其中$VK_{x_k}=v_{x_k}$为该属性的版本密钥，$AA_k$还计算该机构自身的公钥$PK_k=(e(g,g)^{\alpha_k},g^{1/\beta_k},g^{\gamma_k/\beta_k})$。所有的属性公钥和$AA_k$的机构公钥都可以在该机构的“公告栏”获取。</p>
<h5 id="用户私钥生成"><a href="#用户私钥生成" class="headerlink" title="用户私钥生成"></a>用户私钥生成</h5><p>对于每一个用户$U_j(j \in S_U)$，每一个$AA_k$首先用CA的验证密钥$vk_{CA}$验证该用户的证书$Cert(uid)$来判断其是否合法，如果合法，才为其分发密钥。$AA_k$会根据该用户在自己这拥有的属性，计算一系列的用户私钥$SK_{j,k}$。针对每一个$AA_k$，选择一个随机数$t_{j,k} \in \mathbb{Z}_p$，然后计算$SK_{j,k}$如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& SK_{j,k}=( K_{j,k}=g^{\alpha_k/z_j} \cdot g^{au_j} \cdot g^{at_{j,k}/\beta_k}, 
L_{j,k}=g^{\beta_kt_{j,k}/z_j},R_{j,k}=g^{at_{j,k}},  \nonumber\\
& \forall x_k \in S_{j,k}:K_{j,x_k} =g^{\beta_k \gamma_k t_{j,k}/z_j} \cdot (g^{v_{x_k}} \cdot H(x_k))^{\gamma_k \beta_k u_j}). \nonumber
\end{aligned}</script><p>其中，$j \in S_U, k \in S_A$。</p>
<h5 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h5><p>在DO将数据$m$外包到CSP上之前，DO为其进行加密。DO定义自己的访问结构，以线性秘密共享方案的形式，即访问结构为$(M, \rho)$，其中$M$为$l \times n$的矩阵，$l$为所有属性的个数，函数$\rho$将矩阵的每一行映射到一个属性。</p>
<p>首先将消息$m$切分为若干数据块，即$m=\left\{m_1,…,m_n \right\}$，然后针对每一个数据块选择一个对称密钥$\left\{\kappa_1,…, \kappa_n \right\}$，用对称密钥$\kappa_i$加密数据块$m_i$。不失一般性，以下只针对某一个数据块$m$的加密过程进行描述。</p>
<p>DO随机选择秘密值$s \in \mathbb{Z}_p$，选择随机向量$\overrightarrow{v} =(s,y_2,…,y_n) \in \mathbb{Z}_p^n$，其中$y_2,…,y_n$随机选取，其作用是分享秘密值$s$。对于$i \in [l]$，计算$\lambda_i = \overrightarrow {v}M_i$，其中$M_i$为矩阵$M$的第$i$行，然后随机选择$r_1,…,r_l \in \mathbb{Z}_p$，计算密文如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&  CT=(En_\kappa(m), C=\kappa \cdot(\prod_{k \in I_A}e(g,g)^{\alpha_k})^s, C^\prime=g^s,{C}''=g^{s/\beta_k}, \nonumber\\
&  \forall i \in [l]:C_i=g^{a\lambda_i} \cdot ((g^{v_{\rho(i)}}H(\rho(i)))^{\gamma_k})^{-r_i}, D_{1,i}=g^{r_i/\beta_k},D_{2,i}=g^{-\gamma_kr_i/\beta_k}, \rho(i) \in S_{A_k} ). \nonumber
\end{aligned}</script><h5 id="数据解密"><a href="#数据解密" class="headerlink" title="数据解密"></a>数据解密</h5><p>系统中的合法用户可以可以从CSP查询获取任何密文，但是只有属性集合满足访问结构的用户才能够解密出对称密钥，进而恢复出消息$m$。</p>
<h6 id="CSP计算Token"><a href="#CSP计算Token" class="headerlink" title="CSP计算Token"></a>CSP计算Token</h6><p>用户$U_j(j \in S_U)$将他的私钥$\left\{SK_{j,k} \right\}_{k \in S_A}$发送给CSP，让CSP为其计算生成解密令牌$TK$。当且仅当用户的属性集合满足密文的访问结构的时候，CSP才能正确计算出$TK$。</p>
<p>记$I=\left\{I_{A_k} \right\}_{k \in S_A}$为与密文有关的所有索引的集合，其中$I_{A_k} \sqsubset \left\{1,2,…,l \right\}$定义为$I_{A_k}=\left\{i:\rho(i) \in S_{A_k} \right\}$。举个例子，例如矩阵$M$有6行，$\rho(1)$为属性$a_1$，……，$\rho(6)$为属性$a_6$，一共有三个属性机构$A_1,A_2,A_3$，$A_1=\left\{a_1,a_6 \right\}$，$A_2=\left\{a_2,a_4,a_5 \right\}$，$A_3=\left\{a_3 \right\}$，假设用户Alice有属性$\left\{a_1,a_2,a_3,a_4 \right\}$，则$I_{A_1}=\left\{1 \right\}$，$I_{A_2}=\left\{2,4 \right\}$，$I_{A_3}=\left\{3 \right\}$，所以$I=\left\{I_{A_1},I_{A_2},I_{A_3} \right\}=\left\{1,2,3,4\right\}$。</p>
<p>记$N_A=|I_A|$为与密文中属性有关的机构个数（上述例子中$N_A=3$），CSP选择一系列的常数$\left\{\omega_i \in \mathbb{Z}_p \right\}_{i \in I}$，然后重构秘密值$s=\sum_{i \in I} \omega_i \lambda_i$，然后计算$TK$如下。</p>
<script type="math/tex; mode=display">
\begin{aligned}
& TK=\prod_{k \in I_A} \frac{e(C^\prime,K_{j,k}) \cdot e(R_{j,k},{C}'')^{-1}}
{\prod _{i \in I_{A_k}} (e(C_i,GPK_j) \cdot e(D_{1,i},K_{j,\rho(j)}) \cdot e(D_{2,i},L_{j,k}))^{\omega_iN_A}} \nonumber\\
& =\frac{e(g,g)^{au_jsN_A} \cdot \prod_{k \in I_A} e(g,g)^{\alpha_ks/z_j}}
{e(g,g)^{u_jaN_A \sum_{i \in I} \lambda_i \omega_i}} \nonumber \\
& =\prod_{k \in I_A} e(g,g)^{\alpha_ks/z_j}. \nonumber
\end{aligned}</script><p>然后CSP将$TK$返回给用户$U_j$。</p>
<h6 id="用户解密"><a href="#用户解密" class="headerlink" title="用户解密"></a>用户解密</h6><p>用户$U_j$收到$TK$后，用自己的全局私钥$GSK_j=z_j$解密对称密钥$\kappa = \frac{C}{TK^{z_j}}$。然后用对称密钥$\kappa$解密密文$m=Dec_{\kappa}(Enc_{\kappa}(m))$。</p>
<h5 id="属性撤销"><a href="#属性撤销" class="headerlink" title="属性撤销"></a>属性撤销</h5><p>假设属性用户$U_\mu$ 的属性$\widetilde{x}_k$从$AA_k$那撤销了，那么属性撤销阶段分以下三步进行。</p>
<h6 id="AA-s-生成更新密钥"><a href="#AA-s-生成更新密钥" class="headerlink" title="$AA_s$生成更新密钥"></a>$AA_s$生成更新密钥</h6><p>相应的$AA_k$选择一个新的属性$\widetilde{x}_k$的版本密钥$VK_{\widetilde{x}_k}^\prime = v_{\widetilde{x}_k}^\prime$，然后计算属性更新密钥$AUK_{\widetilde{x}_k}=\gamma_k(v_{\widetilde{x}_k}^\prime - v_{\widetilde{x}_k})$，进而生成密钥更新密钥$KUK_{j,\widetilde{x}_k}=g^{u_j \beta_k \cdot AUK_{\widetilde{x}_k}}$和密文更新密钥$CUK_{\widetilde{x}_k} = \beta_k \cdot AUK_{\widetilde{x}_k}/\gamma_k$。然后$AA_k$将属性$\widetilde{x}_k$的属性公钥更新为$PK_{\widetilde{x}_k}^\prime=PK_{\widetilde{x}_k} \cdot g^{AUK_{\widetilde{x}_k}}$，并全系统广播属性$\widetilde{x}_k$有关的密文密钥更新过了。</p>
<h6 id="非撤销用户更新属性部件"><a href="#非撤销用户更新属性部件" class="headerlink" title="非撤销用户更新属性部件"></a>非撤销用户更新属性部件</h6><p>对于那些没有撤销$\widetilde{x}_k$的用户$U_j(j \in S_U,j \neq \mu)$，$AA_k$发给他们密钥更新密钥$KUK_{j,\widetilde{x}_k}$。用户拿到更新密钥后，更新自己的私钥为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& SK_{j,k}^\prime=( K_{j,k}^\prime=K_{j,k}, L_{j,k}^\prime=L_{j,k},R_{j,k}^\prime=R_{j,k}, \nonumber\\
& K_{j,\widetilde{x}_k}^\prime=K_{j,\widetilde{x}_k} \cdot KUK_{j,\widetilde{x}_k}, \forall x_k \in S_u, x_k \neq \widetilde{x}_k:K_{j,x_k}^\prime=K_{j,x_k} ). \nonumber
\end{aligned}</script><h6 id="CSP更新密文部件"><a href="#CSP更新密文部件" class="headerlink" title="CSP更新密文部件"></a>CSP更新密文部件</h6><p>$AA_k$发给CSP密文更新密钥$CUK_{\widetilde{x}_k}$，然后密文更新为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& CT^\prime=(En_\kappa(m), C=\kappa \cdot(\prod_{k \in I_A}e(g,g)^{\alpha_k})^s, C^\prime=g^s,{C}''=g^{s/\beta_k}, \nonumber\\
& \forall i \in [l]: \nonumber\\
& if \rho(i) \neq \widetilde{x}_k: C_i=g^{a\lambda_i} \cdot ((g^{v_{\rho(i)}}H(\rho(i)))^{\gamma_k})^{-r_i}, \nonumber\\ & D_{1,i}=g^{r_i/\beta_k},D_{2,i}=g^{-\gamma_kr_i/\beta_k}, \nonumber\\ 
& if \rho(i) = \widetilde{x}_k: C_i^\prime = C_i \cdot D_{2,i}^{CUK_{\widetilde{x}_k}}, \nonumber\\
& D_{1,i}=g^{r_i/\beta_k},D_{2,i}=g^{-\gamma_kr_i/\beta_k}). \nonumber
\end{aligned}</script><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从具体的构造来看，DAC-MACS设计的还是相当的复杂，这是因为ABE算法本身就需要考虑诸多属性，而与之有关的有密文和密钥两大部分，再加上要设计成多个权威机构，那么系统中与属性相关联的又多了一层实体。这可以和Chase的方案对比，很明显其复杂度不言而喻，因为Chase的ABE方案算是门限ABE，而且没有属性撤销这一安全需求。</p>
<p>从DAC-MACS的设计中可以看到，每一个AA的主密钥有三个之多，这正是为了实现后边的属性撤销而预设的。回头看一下，DAC-MAC是将一个所谓的属性的版本密钥嵌入到属性有关部件里边，然后有属性撤销发生，则将对应的版本密钥更新，这样做的好处是，只有与撤销有关的密文密钥部件才会更新值，而不相关属性的部件不会变化，大大减少了撤销时的计算量，因此这种撤销的手段是很典型的高效撤销机制。</p>
<p>而DAC-MACS又是如何实现解密操作外包的呢？这是由于CSP为用户计算生成解密令牌，而大大减少了用户的解密开销，之所以用户将私钥给CSP也不会产生安全隐患，这是因为密钥中嵌入了用户的全局私钥信息，这一随机数其实就是O-ABE中盲化技术里的盲化因子。</p>
<p>DAC-MACS中提到了假定非撤销用户不会将密钥更新密钥透露给非撤销用户，这是因为如果透露了，那么撤销用户仍然能够更新自己的私钥，从而解密最近的密文。正因为如此，作者才推出EDAC-MACS来消除这一假设前提，以增强方案的安全性，但是Wu<sup><a href="ref1">5</a></sup>等人针对EDAC-MACS方案，还是分析出其中的漏洞。不过不管怎样，DAC-MACS还是一种经典的多属性权威ABE方案的构造，其中的细节值得回味，其中的技巧值得借鉴。</p>
<p><span name="ref1">K. Yang, X. H. Jia, K. Ren, B. Zhang, and R. T. Xie, “DAC-MACS: Effective Data Access Control for Multi-authority Cloud Storage Systems,” <em>IEEE Transactions on Information Forensics and Security</em>, vol. 8, no.11, pp. 1790-1801, Nov. 2013.</span></p>
<p><span name="ref2">M. Chase, “Multi-authority attribute based encryption,” in <em>Proc. TCC’07</em>, 2007, pp. 515–534, Springer.</span></p>
<p><span name="ref3">B. Waters, “Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization,” in <em>Proc. PKC’11</em>, 2011, pp. 53–70, Springer.</span></p>
<p><span name="ref4">M. Green, S. Hohenberger, and B. Waters, “Outsourcing the Decryption of ABE Ciphertexts,” in <em>Proceedings of the 20th USENIX conference on Security</em>, San Francisco, CA, USA, 2011.</span></p>
<p><span name="ref5">X. Wu, R. Jiang and B. Bhargava, “On the Security of Data Access Control for Multiauthority Cloud Storage Systems,” <em>IEEE Transactions on Services Computing</em>, vol. 10, no. 2, pp. 258-272, 1 March-April 2017.<span></span></span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>属性撤销</tag>
        <tag>共谋攻击</tag>
        <tag>多个属性机构</tag>
        <tag>外包解密</tag>
      </tags>
  </entry>
  <entry>
    <title>Hur2-ABE</title>
    <url>/2021/04/12/Hur2-ABE/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>前面介绍了Hur1-ABE<sup><a href="ref1">1</a></sup>，主要是在最原始的CP-ABE上边增加了属性撤销这一安全需求，而为实现属性撤销，借助了密钥更新树（KEK  Tree）这一技巧。今天介绍的Hur2-ABE<sup><a href="ref2">2</a></sup>方案，仍然是侧重属性撤销，但是并没有借助密钥更新树这类结构，而是借助多项式完成属性密钥的更新。除此之外，Hur2-ABE方案还在一定程度上解决了密钥托管的问题。在正式介绍方案具体构造之前，我们先来认识一下密钥托管问题以及文中提到的单向匿名密钥协商协议。</p>
<span id="more"></span>
<h4 id="密钥托管"><a href="#密钥托管" class="headerlink" title="密钥托管"></a>密钥托管</h4><p>密钥托管问题描述的是，密钥产生中心（有的地方叫做属性权威机构、可信中心等等）作为计算产生用户私钥的权威机构，一般在方案的系统模型中都是假定“诚实”的，这也就意味着系统中任何一个用户的私钥它都是知道到了，原则上来说它具有解密任何密文的能力。而在实际中对密钥产生中心的依赖当然是越弱越好。因此有的ABE通过研究削弱对用户密钥的的这种完全托管，使得密钥产生中心在“沦陷”之后，用户密钥还能不公开。</p>
<p>一般来说有两种常见的解决思路，一种是将一个密钥产生中心按照属性域的区别，划分为多个属性权威机构，而另一种是密钥产生中心与其他实体交互产生用户密钥。Hur2-ABE就是通过第二种机制，来消除密钥托管，文中将该方法叫做2PC，即两部分计算。</p>
<h4 id="单向匿名密钥协商"><a href="#单向匿名密钥协商" class="headerlink" title="单向匿名密钥协商"></a>单向匿名密钥协商</h4><p>密钥协商在两个乃至多个实体之间秘密通信显得尤为重要，而现实中又有些场景既需要秘密通信，又希望向对方隐藏自己的身份。文中描述了单向匿名密钥协商协议，具体过程如下：</p>
<img src="/2021/04/12/Hur2-ABE/two_PC.PNG" class title="2PC Process">
<ol>
<li>假设Alice和Bob是某个权威机构的用户，Alice的身份为$ID_A$，权威机构给她的私钥为$d_A=Q_A^s=H(ID_A)^s$。现在Alice希望与身份为$ID_B$的Bob通信并保持匿名；</li>
<li>Alice计算$Q_B=H(ID_B)$，然后她选择随机数$r_A \in \mathbb{Z}_p$，产生一个过渡值$P_A=Q_A^{r_A}$，计算会话秘钥为$K_{A,B}=e(d_A, Q_B)^{r_A}=e(Q_A,Q_B)^{sr_A}$，最后Alice将过渡值$P_A$发送为Bob；</li>
<li>Bob收到$P_A$后计算出会话密钥$K_{A,B}=e(P_A, d_B)=e(Q_A,Q_B)^{sr_A}$。</li>
</ol>
<p>经过如上步骤的交互Alice和Bob即可以用协商的会话密钥通信；另一方面，Alice知道Bob的身份，但是Alice发给Bob的$P_A$中虽然含有其身份哈希值项，但是因为计算Diffie-Hellman难题假设（CDH），所以过程中BOb是不知道Alice的身份，从而保证了Alice对于Bob来说的匿名。</p>
<h4 id="方案具体构造"><a href="#方案具体构造" class="headerlink" title="方案具体构造"></a>方案具体构造</h4><h5 id="System-Setup"><a href="#System-Setup" class="headerlink" title="System Setup"></a><strong>System Setup</strong></h5><p>在系统初始化阶段，可信的初始化方初始化系统（这个地方不再是密钥产生中心初始化系统，因为要运用2PC消除密钥托管，因而密钥产生中心KGC和云服务器提供商DSC都是假定为“诚实且好奇”的）。选择双线性群$\mathbb{G}_0$，阶数为$p$，生成元为$g$。选择哈希函数$H:\left \{ 0,1 \right \}^+ \rightarrow \mathbb{G}_0$，选择单向函数$\mathbb{G}_1 \rightarrow \mathbb{Z}_p$。系统的公开参数$param=(\mathbb{G}_0, g,H_1, H_2)$。</p>
<h6 id="KGC初始化"><a href="#KGC初始化" class="headerlink" title="KGC初始化"></a>KGC初始化</h6><p>KGC随机选择指数$\beta \in \mathbb{Z}_p$，令$h=g^\beta$。KGC的主密钥和公钥分别为$PK_K=h$，$MK_K=\beta$。</p>
<h6 id="DSC初始化"><a href="#DSC初始化" class="headerlink" title="DSC初始化"></a>DSC初始化</h6><p>DSC随机选择指数$\alpha \in \mathbb{Z}_p$。DSC的主密钥和公钥分别为$PK_D=e(g,g)^\alpha$，$MK_D=g^\alpha$。DSC随机选择指数$\gamma \in \mathbb{Z}_p$，将$\gamma$保密，将$PK_D^{agree}=g^\gamma$公开以作为分享群密钥用。</p>
<h5 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key Generation"></a>Key Generation</h5><h6 id="属性无关密钥生成"><a href="#属性无关密钥生成" class="headerlink" title="属性无关密钥生成"></a>属性无关密钥生成</h6><p>KGC和DSC通过以下2PC协议产生用户私钥（与属性无关部分），具体如下：</p>
<ol>
<li>KGC认证一个用户$u_t$的身份时，为该用户生成一个全局一致的指数$r_t \in \mathbb{Z}_p$，这个数对于每个用户是唯一且与其他用户不同。KGC一侧需要输入的是（$r_t, \beta$），DSC一侧输入的是$\alpha$。首先KGC与DSC通过2PC计算$x=(\alpha+r_t)\beta$，然后KGC将$x$发送给DSC；</li>
<li>DSC随机选择$\tau \in \mathbb{Z}_p$，计算$A=g^{x/\tau}=g^{(\alpha+r_t)\beta/ \tau}$，将$A$发送给KGC；</li>
<li>KGC计算$B=A^{1/\beta^2}=g^{(\alpha+r_t)/(\tau \beta)}$，将$B$发送给DSC；</li>
<li>DSC最终输出用户$u_t$与属性无关的私钥部件$D=B^\tau =g^{(\alpha+r_t)/\beta}$。</li>
</ol>
<h6 id="属性有关密钥生成"><a href="#属性有关密钥生成" class="headerlink" title="属性有关密钥生成"></a>属性有关密钥生成</h6><p>给定一个用户的属性集合$S $，KGC产生属性有关的用户密钥（即属性密钥），具体如下：</p>
<p>KGC对于每一个属性$\forall j \in S $， 随机选择$r_j \in \mathbb{Z}_p$，然后计算密钥如下：</p>
<script type="math/tex; mode=display">
SK_{K,u_t}=\left( \forall j \in S : D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=g^{r_j} \right).</script><p>最终用户$u_t$的密钥由这两部分构成，即</p>
<script type="math/tex; mode=display">
SK_{u_t}=\left( D=g^{\left(\alpha +r_t \right)/\beta}, \forall j \in S : D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=g^{r_j} \right).</script><p>DSC输出另一个KEK密钥$SK_{u_t}^{agree}=H(ID_t)^\gamma=Q_t^\gamma$，该密钥是为了属性群密钥的密钥分发。</p>
<h5 id="Data-Encryption"><a href="#Data-Encryption" class="headerlink" title="Data Encryption"></a>Data Encryption</h5><p>数据拥有者定义一个访问结构$\mathcal{T}$（访问控制树形式），然后按如下方式进行加密：</p>
<p>针对树$\mathcal{T}$中的每一个节点$x$（包括联系属性的叶子节点），选择一个与之对应的多项式$q_x$。多项式$q_x$的的最高次数为$d_x=k_x-1$。</p>
<p>多项式的选取遵循由根节点到叶子节点（从上到下）的方式。从根节点$R$开始，选择秘密值$s \in \mathbb{Z}_p$，并设置$q_R \left(0 \right)=s$，然后随机选择其他项的次数。对于其他节点$x$，递归的设置$q_x \left( 0 \right) = q_{p\left(x \right)} \left(index\left(x \right) \right)$，至于$q_x$的其他系数随机选择。</p>
<p>记$Y$为树$\mathcal{T}$的叶子节点的集合，然后加密消息$M \in \mathbb{G}_1$，密文可以表示为：</p>
<script type="math/tex; mode=display">
CT=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},
C_y^\prime=H \left(\lambda_y \right) ^ {q_y \left( 0  \right )} \right).</script><p>其中，$\lambda_y$表示的是叶子节点$y$对应的属性，$H \left(\cdot \right)$表示将属性映射到$\mathbb{G}_0$。</p>
<p>此阶段和CP-ABE方案中的加密阶段一致。</p>
<h5 id="Data-Re-Encryption"><a href="#Data-Re-Encryption" class="headerlink" title="Data Re-Encryption"></a>Data Re-Encryption</h5><p>此阶段DSP将重加密密文$CT$，具体如下：</p>
<ul>
<li>对于访问结构中涉及到的属性群$\left\{ G_y:y \in Y \right\}$，DSP随机选择属性群密钥$K_{\lambda_y} \in \mathbb{Z}_p$，然后重加密$CT$进而产生$CT^\prime$。</li>
</ul>
<script type="math/tex; mode=display">
CT^\prime=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},C_y^\prime=\left(H \left(\lambda_y \right) ^ {q_y \left( 0  \right )} \right)^{K_{\lambda_y}}\right).</script><ul>
<li>选择随机数$\rho,R \in \mathbb{Z}_p$，对于$\forall u_t \in G$（此处的$G$表示所有用户组成的群），计算$x_t=H_1(e(Q_t^\rho, PK_D^{agree}))$，此处的$x_t$可以在系统初始化的时候提前计算，而且只计算一次，$x_t$相当于是在$\mathbb{Z}_p$中用户$x_t$的身份；</li>
<li>对于所有的$\forall G_y$，构造多项式函数$f^y(x)=\prod_{i=1}^m(x-x_i)=\sum_{i=0}^m a_ix^i (mod \ p)$，其中$G_y=\left\{ u_1,u_2,…,u_m \right\}$表示属性群$G_y$中有$m$个用户，记指数集合$\left\{ P_0,P_1,…,P_m\right\} = \left\{ g^{a_0},g^{a_1},…,g^{a_m}\right\}$；</li>
<li>构造$Hdr_y=\left\{ K_{\lambda_y } \cdot P_0^R, P_1^R,…, P_m^R\right\}$，公开$Hdr=(g^\rho, \forall y \in Y:Hdr_y)$。</li>
</ul>
<h5 id="Data-Decryption"><a href="#Data-Decryption" class="headerlink" title="Data Decryption"></a>Data Decryption</h5><p>密文的形式为：</p>
<script type="math/tex; mode=display">
CT^\prime=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},C_y^\prime=\left(H \left(\lambda_y \right) ^ {q_y \left( 0  \right )} \right)^{K_{\lambda_y}}\right).</script><p>密钥的形式为：</p>
<script type="math/tex; mode=display">
SK_t=\left( D=g^{\left(\alpha +r \right)/\beta}, \forall \lambda_j \in \Lambda : D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=g^{r_j} \right).</script><h6 id="属性群密钥解密"><a href="#属性群密钥解密" class="headerlink" title="属性群密钥解密"></a>属性群密钥解密</h6><p>当用户收到$Hdr$后，首先解密属性群密钥。如果用户$u_t$持有属性$\lambda_j$，那么他能解密$K_{\lambda_j}$，他可以按照如下方式解密群密钥$K_{\lambda_j}$：</p>
<ul>
<li>用户$u_t$首先计算$x_t=H_1(e(g\rho, SK_{u_t}^{agree}))$；</li>
<li>计算$K_{\lambda_y} \cdot P_0^R \cdot \prod _{i=1}^m (P_i^R)^{x_t^i}=K_{\lambda_y} \cdot g^{Rf^j(x_i)}=K_{\lambda_y}$，其中$m=|G_j|$。</li>
</ul>
<p>得到群密钥$K_{\lambda_j}$之后，用户$u_t$更新自己的私钥为：</p>
<script type="math/tex; mode=display">
SK_{u_t}=\left( D=g^{\left(\alpha +r_t \right)/\beta}, \forall \lambda_j \in \Lambda : D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=(g^{r_j})^{1/K_{\lambda_j}} \right).</script><h6 id="密文解密"><a href="#密文解密" class="headerlink" title="密文解密"></a>密文解密</h6><p>首先定义一个递归的函数$DecryptNode(CT^\prime,SK,x)$（由下到上）:</p>
<ul>
<li><p>如果$x$为叶子节点，记$i=\lambda_x$。</p>
<ul>
<li><p>若$i \in \Lambda$（用户拥有属性$i$），则</p>
<script type="math/tex; mode=display">
\begin{aligned}
&DecryptNode(CT,SK,x) = \frac{e(D_i, C_x)}{e(D_i^\prime , C_x^ \prime)}= \nonumber \\ &\frac{e(g^r \cdot H(x)^{r_i}, h^{q_x(0)})}{(e(g^{r_i})^{1/K_{\lambda_x}} , (H(i)^{q_x(0)})^{K_{\lambda_x}})} = e(g,g)^{rq_x(0)}. \nonumber
\end{aligned}</script></li>
<li><p>若$i \notin \Lambda$，则定义$DecryptNode(CT,SK,x) =\perp $。</p>
</li>
</ul>
</li>
<li><p>如果$x$为非叶子节点，则$DecryptNode(CT,SK,x)$的计算规则如下：</p>
<ul>
<li><p>对于$x$节点的所有孩子节点$z$，调用$F_z = DecryptNode(CT,SK,z)$函数，记$F_z \neq \perp $的所有节点的集合为$S^ \prime$，若$|S^ \prime|&lt;k_x$，则$DecryptNode(CT,SK,x) =\perp $。</p>
</li>
<li><p>相反的话，则选取$S^ \prime$集合中任意$k_x$个元素组成集合$S_x$，按如下方式计算$DecryptNode(CT,SK,x)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&F_z=\prod _{z \in S_x} F_z ^{\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g) ^ {rq_z(0)}) ^ {\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g) ^ {rq_{p(z)}(index(z))}) ^ {\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g)  ^ {r \cdot q_x(i) \cdot \Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=e(g,g)^{rq_x(0)}.\nonumber
\end{aligned}</script></li>
</ul>
</li>
</ul>
<p>从递归函数的形式上看，尽管叶子节点和非叶子节点的具体计算方式不一样，但是有着统一的形式，因此只要能够依次满足条件地计算出树中适当个数的节点秘密值，就可以解密根节点的秘密值。即当属性集合$S$满足访问结构$\mathcal{T}$，那么就可以解密得到:</p>
<script type="math/tex; mode=display">
A = DecryptNode(CT,SK,r)=e(g,g)^{rq_R(0)} = e(g,g)^{rs}.</script><p>最后即可解密成功：</p>
<script type="math/tex; mode=display">
\widetilde{C}/(e(C,D)/A) = \widetilde{C}/(e(h^s,g^{((\alpha + r)/\beta )})/e(g,g)^{rs}) = M.</script><h5 id="Attribute-Revocation"><a href="#Attribute-Revocation" class="headerlink" title="Attribute Revocation"></a>Attribute Revocation</h5><p>假设属性群$G_i$中有成员变动（某用户撤销了属性$\lambda_i$），则需要更新密文和密钥，具体如下：</p>
<ul>
<li>DSC随机选择一个秘密值$s^\prime \in \mathbb{Z}_p$，然后再随机选取一个不一样的群密钥$K_{\lambda_i}^\prime \in \mathbb{Z}_p$，然后重加密密文得到新密文：</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
& CT^\prime=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha (s+s^\prime)},C=h^{s+s^\prime},C_i=g^{q_i \left(0 \right )+s^\prime},C_i^\prime=\left(H \left(\lambda_i \right) ^ {q_i \left( 0  \right )+s^\prime} \right)^{K_{\lambda_y}^\prime}, \nonumber \\
 \forall y \in Y\setminus \left\{i \right\}:C_y=g^{q_y \left(0 \right )+s^\prime},C_y^\prime=\left(H \left(\lambda_y \right) ^ {q_y \left( 0  \right )+s^\prime} \right)^{K_{\lambda_y}}\right). \nonumber
\end{aligned}</script><ul>
<li>DSC针对属性$\lambda_i$，重新构造多项式$f^i(x)$，只不过这个时候的属性群是更新后的属性群，去除了撤销属性$\lambda_i$的成员，增加了新持有属性$\lambda_i$的成员。然后根据新的属性群密钥，重新计算生成$Hdr_i$，并公开最新的$Hdr$为：$Hdr = (g^\rho, Hdr_i, \forall y \in Y \setminus \left\{i \right\}:Hdr_y)$。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Hur2-ABE和Hur1-ABE的构造思路很相近，都是构建在最初的CP-ABE方案之上，都是为了解决属性撤销的难题，只不过属性撤销实现的方式不同，具体表现为Hur1-ABE是借助KEK树的技巧实现的，而Hur2-ABE是通过多项式技巧实现的，都是基于属性群的实现。不同的是，Hur2-ABE还利用2PC让KGC和DSC交互来产生用户私钥中与属性无关的部件，从而消除密钥托管。然而，不管是Hur1-ABE还是Hur2-ABE，都不能抵抗一种共谋攻击，即属性撤销用户与未撤销用户之间的共谋，这是因为如果未撤销的用户直接将属性群密钥泄露给撤销用户，那么属性撤销用户就可以绕过计算群密钥的限制而得到群密钥，进而更新自己的私钥到最新版解密密文，因此原文中加入了不存在这种攻击的假设。这两种经典的撤销手段给了ABE的属性撤销机制良好的启发作用，值得回味。</p>
<p><span name="ref1">J. Hur and D. K. Noh, “Attribute-based Access Control with Efficient Revocation in Data Outsourcing Systems,” IEEE Transactions on Parallel and Distributed Systems, vol. 22, no. 7, pp. 1214–1221, Jul. 2011.</span></p>
<p><span name="ref2">J. Hur, “Improving Security and Efficiency in Attribute-Based Data Sharing,” IEEE Transactions on Knowledge and Data Engineering, vol. 25, no. 10, pp. 2271-2282, Oct. 2013.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>属性撤销</tag>
        <tag>共谋攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>MA-ABE</title>
    <url>/2021/04/13/MA-ABE/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在前面提到的Hur1-ABE和Hur2-ABE方案中都提到了密钥托管和共谋攻击的问题。密钥托管说的是密钥产生中心（KGC）为用户计算生成私钥，从而有解密任何密文的能力；而共谋攻击指的是几个实体试图“勾结起来”将自己的属性拼拼凑凑以满足访问结构达到解密密文的目的。其实在原始CP-ABE方案提出的同一年（2007年），就有学者关注这两个问题，并给出了自己的解决方案，这就是Chase的MA-ABE<sup><a href="ref1">1</a></sup>方案。</p>
<span id="more"></span>
<p>针对密钥托管的问题，MA-ABE方案将一个密钥产生中心（KGC）“分裂为”多个属性机构，每个属性机构只是负责管理与该属性有关的用户，属性机构之间没有任何关联，管理的属性集合之间也没有交集；针对共谋攻击的问题，MA-ABE方案首次提出GID的概念，即针对每个用户以及每个属性机构分配一个全局唯一的身份标识符，用户私钥的的产生与这些唯一的标志相关联。那么我们来看一看MA-ABE方案是怎么构造的吧！</p>
<h4 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h4><p>再具体描述方案的构造之前，首先说明一下系统所用的符号解释以及系统假设：</p>
<ul>
<li>系统属性域可划分为$K$个互不相交的属性集合，每一个集合的属性由对应的属性机构所管理。系统中有一个可信的中心机构CA，只不过该机构不负责管理任何属性。</li>
<li>记$\mathcal{A}_u$为用户$u$的属性集合，$\mathcal{A}_C$为密文中的属性集合；$\mathcal{A}_u^k$为$\mathcal{A}_u$中由属性机构$k$管理的属性集合，$\mathcal{A}_C^k$为$\mathcal{A}_C$中由属性机构$k$管理的属性集合。</li>
</ul>
<p>因为MA-ABE方案是将Sahai和Waters的FIBE（或者说门限ABE）方案拓展到多个权威机构，因此MA-ABE这篇文献非常“耐心”地一步步引导读者如何构建MA-ABE方案，这无疑说是一览ABE构思细节的“福利”。下面按照文献的思路一步步介绍。</p>
<h5 id="STEP-ONE"><a href="#STEP-ONE" class="headerlink" title="STEP ONE"></a>STEP ONE</h5><h6 id="方案构造前思忖"><a href="#方案构造前思忖" class="headerlink" title="方案构造前思忖"></a>方案构造前思忖</h6><p>根据之前说的拉格朗日插值算法可知，给定一个$d-1$次多项式的$d$个点$p(1),p(2),…,p(d)$，那么我们可以恢复出多项式$p(x)$进而计算任何指定的值$p(i)$。同样的，如果我们给定$d$个数，分别为$g^{p(1)},g^{p(2)},…,g^{p(d)}$，我们仍然可以同样的计算得到$g^{p(x)}$，进而计算任何给定$i$所对应的$g^{p(i)}$。</p>
<p>这给我们构建ABE方案一些启示：如果某个用户拥有属性$i$，那么他的私钥就含有$g^{p(i)}$，其中多项式$p$的次数为$d-1$。我们可以通过计算$g^{p(0)}m$来给消息$m$进行加密，只要任何用户有至少$d$个属性即可通过插值的方式解密$m$。然而这样不能防止共谋攻击，因为只要几个用户通过“拼凑”自己的属性使得总属性个数多于$d$，仍然可以解密。那么自然想到的是，针对一个用户$u$，选择某个特定的多项式$p_u$，然后再分发密钥，只不过所有的多项式必须在0点处相交，即$y=p_1(0)=…=p_i(0)$。下面基于这种思路构建STEP ONE方案。</p>
<h6 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h6><p>从$\mathbb{Z}_p$中随机选择主密钥$y$。</p>
<h6 id="SK-Gen"><a href="#SK-Gen" class="headerlink" title="SK Gen"></a>SK Gen</h6><p>对于用户$u$，随机选择多项式$p$使得$p(0)=y$，然后生成用户$u$的密钥为$SK=\left\{ D_i = g^{p(i）} \right\}_{\forall i \in \mathcal{A}_u}$。</p>
<h6 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h6><p>计算$E=g^ym$。</p>
<h6 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h6><p>如果用户$u$有至少$d$个密钥部件，那么他可以用其中的$d$个通过插值计算$Y=g^{p(0)}=g^y$，然后$m=E/Y$。</p>
<h5 id="STEP-TWO"><a href="#STEP-TWO" class="headerlink" title="STEP TWO"></a>STEP TWO</h5><h6 id="方案构造前思忖-1"><a href="#方案构造前思忖-1" class="headerlink" title="方案构造前思忖"></a>方案构造前思忖</h6><p>如果采用Step One中的方案，那么意味着任何用户只要有$d$个属性，就可以解密密文，而我们希望的是在给定的属性集合范围内满足至少$d$个属性才能够解密。为了达到这个需求，我们得借助双线性映射$e$（对于$g\in \mathbb{G}_1$，$a,b \in \mathbb{Z}_q$，则$e(g^a, g^b)=e(g,g)^{ab}$）。</p>
<p>现在假定我们不再是针对每个属性$i$分发属性密钥$g^{p(i)}$，而是选择一个随机值$t_i$，然后分发属性密钥$g^{p(i)/t_i}$。如果用户知道至少$d$个$g^{t_i}$，那么他可以计算至少$d$个$e(g,g)^{p(i)}$，然后通过插值得到$e(g,g)^{p(0)}$。假如消息$m$加密为$e(g,g)^{p(0)}m$，那么他就可以解密。这样，加密者就可以指定是哪些属性可以提供$g^{t_i}$。下面基于这种思路构建Step Two方案。</p>
<h6 id="Init-1"><a href="#Init-1" class="headerlink" title="Init"></a>Init</h6><p>首先从$\mathbb{Z}_p$中随机选择$y,t_1,…,t_n$，令$Y=e(g,g)^y$。</p>
<h6 id="SK-Gen-1"><a href="#SK-Gen-1" class="headerlink" title="SK Gen"></a>SK Gen</h6><p>随机选择一个多项式$p$使得$p(0)=y$，然后生成密钥为$SK=\left\{ D_i = g^{p(i)/t_i} \right\}_{\forall i \in \mathcal{A}_u}$。</p>
<h6 id="Encryption-1"><a href="#Encryption-1" class="headerlink" title="Encryption"></a>Encryption</h6><p>计算$E=Ym$以及$\left\{E_i=g^{t_i} \right\}_{\forall i \in \mathcal{A}_C}$。</p>
<h6 id="Decryption-1"><a href="#Decryption-1" class="headerlink" title="Decryption"></a>Decryption</h6><p>如果用户$u$有至少$d$个$i \in \mathcal{A}_C \cap \mathcal{A}_u$，那么他可以用其中的$d$个计算$e(E_i,D_i)=e(g,g)^{p(i)}$，通过插值计算$Y=e(g,g)^{p(0)}=e(g,g)^y$，然后$m=E/Y$。</p>
<h5 id="STEP-THREE"><a href="#STEP-THREE" class="headerlink" title="STEP THREE"></a>STEP THREE</h5><h6 id="方案构造前思忖-2"><a href="#方案构造前思忖-2" class="headerlink" title="方案构造前思忖"></a>方案构造前思忖</h6><p>STEP TWO方案中存在许多问题。首先，我们需要多次加密消息，但不希望每次加密都重新运行一遍系统。然而STEP TWO中一旦用户恢复出$Y=e(g,g)^{p(0)}$，他便可以解密该系统后边加密的任何消息了，而不管他的属性是否满足要求。</p>
<p>如果加密消息的时候我们不是给定$e(g,g)^{p(0)}m$，而是给定$e(g,g)^{p(0)s}m$，这里的$s$是每次加密消息时不同的值呢？这样的话，我们的密文部件相应地由$\left\{E_i=g^{t_i} \right\}_{ \forall i \in \mathcal{A}_C}$变为$\left\{E_i=g^{t_is} \right\}_{ \forall i \in \mathcal{A}_C}$，这样的话，上述流程仍能保证只要用户有足够的属性，他仍能计算得到$e(g,g)^{p(0)s}$，从而解密密文。下面基于这种思路构建STEPTHREE方案，也即重构FIBE方案。</p>
<h6 id="Init-2"><a href="#Init-2" class="headerlink" title="Init"></a>Init</h6><p>首先从$\mathbb{Z}_p$中随机选择$y,t_1,…,t_n$。</p>
<h6 id="PK-Gen"><a href="#PK-Gen" class="headerlink" title="PK Gen"></a>PK Gen</h6><p>$T_1=g^{t_1}, …,T_n=g^{t_n}$，$Y=e(g,g)^y$，$PK=\left\{ T_i\right\}_{1\leq i\leq n},Y$。</p>
<h6 id="SK-Gen-2"><a href="#SK-Gen-2" class="headerlink" title="SK Gen"></a>SK Gen</h6><p>随机选择一个多项式$p$使得$p(0)=y$，然后生成密钥为$SK=\left\{ D_i = g^{p(i)/t_i} \right\}_{\forall i \in \mathcal{A}_u}$。</p>
<h6 id="Encryption-2"><a href="#Encryption-2" class="headerlink" title="Encryption"></a>Encryption</h6><p>计算$E=Y^sm=e(g,g)^{ys}m$以及$\left\{E_i=g^{t_is} \right\}_{\forall i \in \mathcal{A}_C}$。</p>
<h6 id="Decryption-2"><a href="#Decryption-2" class="headerlink" title="Decryption"></a>Decryption</h6><p>如果用户$u$有至少$d$个$i \in \mathcal{A}_C \cap \mathcal{A}_u$，那么他可以用其中的$d$个计算$e(E_i,D_i)=e(g,g)^{p(i)s}$，通过插值计算$Y^s=e(g,g)^{p(0)s}=e(g,g)^{ys}$，然后$m=E/Y^s$。</p>
<h5 id="STEP-FOUR"><a href="#STEP-FOUR" class="headerlink" title="STEP FOUR"></a>STEP FOUR</h5><h6 id="方案构造前思忖-3"><a href="#方案构造前思忖-3" class="headerlink" title="方案构造前思忖"></a>方案构造前思忖</h6><p>我们现在考虑多个属性机构的情况。既然我们把属性域划分为$K$个互不相交的属性集合，每个属性集合有一个属性机构管理，那么按照STEP THREE的思路，我们针对每一个属性机构$k$，都构建一个多项式，我们将$y_k$作为属性机构$k$所需要的分享的秘密值，这样的话如果用户$u$拥有足够多的属性机构$k$管理的属性，那么他就可以计算出$e(g,g)^{y_ks}$，而对于每个属性机构来说，设置系统要分享的秘密值$y_0$，使得$\sum y_k = y_0$，我们最终可以得到$e(g,g)^{y_0s}$，将消息$m$加密为$e(g,g)^{y_0s}m$，那么我们满足条件就可以解密密文，符合预期结果。下面基于这种思路构建STEP FOUR方案。</p>
<h6 id="System"><a href="#System" class="headerlink" title="System"></a>System</h6><ol>
<li><strong>Init</strong>. 首先选定$y_1,…,y_k$，$\left\{t_{k,i} \in \mathbb{Z}_q \right\}_{i=1…n,k=1…K}$，令$y_0=\sum _{k=1}^Ky_k$。</li>
<li><strong>System PK</strong>. $Y_0=e(g,g)^{y_0}$。</li>
</ol>
<h6 id="Attribute-Authority-k"><a href="#Attribute-Authority-k" class="headerlink" title="Attribute Authority $k$"></a>Attribute Authority $k$</h6><ol>
<li><strong>Authority Secret Key</strong>. FIBE方案的私钥一样：$y_k, t_{k,1},…,t_{k,n}$。</li>
<li><strong>Authority Public Key</strong>. FIBE方案的公钥一样：$T_{k,1}, …,T_{k,n}$，其中$T_{k,i}=g^{t_{k,i}}$。</li>
<li><strong>Secret Key for User $u$ from authority $k$</strong>. 选择$d-1$阶多项式$p$，其中$p(0)=y_k$。用户私钥为：$\left\{ D_{k,i} = g^{p(i)/t_{k,i}} \right\}_{\forall i \in \mathcal{A}_u}$ 。</li>
</ol>
<h6 id="Encryption-for-attribute-set-mathcal-A-C"><a href="#Encryption-for-attribute-set-mathcal-A-C" class="headerlink" title="Encryption for attribute set $\mathcal{A}_C$"></a>Encryption for attribute set $\mathcal{A}_C$</h6><p>选择随机数$s \in \mathbb{Z}_p$，计算$E=Y_0^sm$以及$\left\{E_{k,i}=T_{k,i}^s \right\}_{\forall i \in \mathcal{A}_C^k,\forall k}$。</p>
<h6 id="Decryption-3"><a href="#Decryption-3" class="headerlink" title="Decryption"></a>Decryption</h6><p>对于每个属性机构$k$，针对$d$个属性$i$，其中$i$满足$i \in \mathcal{A}_C^k \cap \mathcal{A}_u$，计算$e(E_{k,i}, D_{k,i})=e(g,g)^{p(i)s}$。通过插值得到$Y_k^s=e(g,g)^{p(0)s}=e(g,g)^{y_ks}$，进而得到$\prod _{k=1}^K Y_k^s = Y_0^s$，然后$m=E/Y_0^s$。</p>
<h5 id="Final-MA-ABE"><a href="#Final-MA-ABE" class="headerlink" title="Final MA-ABE"></a>Final MA-ABE</h5><h6 id="方案构造前思忖-4"><a href="#方案构造前思忖-4" class="headerlink" title="方案构造前思忖"></a>方案构造前思忖</h6><p>STEP FOUR方案依然存在一个问题。假如我们有$K$个用户，每个用户都能满足一个对应的属性机构的访问要求，然而却没有任何其他属性机构管理的属性，那么这$K$个用户共谋起来仍然能够解密密文，也就是说，$K$个上述用户的组合和一个能够解密密文的合法用户看起来是不可分辨的。为解决这个问题，就提出了GID的概念，将每一个用户与唯一的标识符相关联。</p>
<p>既然我们可以用GID区分不同的用户了，我们需要一些方式来确保不同用户并不能组合来自不同权威机构的密钥，进而解密密文。假设每个权威机构$k$为每个用户选择一个不同的随机数$y_{k,u}$，令$y_{u,0}$为用户$u$的主密钥，那么用户$u$得到$e(g,g)^{y_{k,u}s}$并与用户$u\prime$分享，用户$u\prime$得不到任何关于他主密钥$e(g,g)^{y_{0.u\prime}s}=\prod _{i=1}^Ke(g,g)^{y_{0.u\prime}s}$，因为$y_{k,u}$与$y_{k,u\prime}$是相互独立的。</p>
<p>然而如果所有的属性机构选择$y_{k,u}$独立，那么我们如何保证$\sum_{k=1}^Ky_{k,u}=y_0$对于所用用户都成立呢？似乎需要这些机构之间通信来解决协调一致，但是这又与设计的初衷相违背，原来设想这些机构是不需要沟通的。因此，方案中提到了CA的概念，即一个可信的中心机构，它并不管理属性，它的作用是“协调”各属性机构密钥状态，使得不同的合法用户最终都能计算得到“公共的中间值”，进而解密密文。下面基于这种思路构建最终的MA-ABE。</p>
<h6 id="System-1"><a href="#System-1" class="headerlink" title="System"></a>System</h6><ol>
<li><strong>Init</strong>. 选定素数阶乘法循环群$\mathbb{G},\mathbb{G}_1$，双线性映射$e:\mathbb{G} \rightarrow \mathbb{G}_1$，$g \in \mathbb{G}$为生成元。为每一个属性机构选择种子$s_1,…,s_K$，从$\mathbb{Z}_q$中选择$y_0,\left\{t_{k,i} \in \mathbb{Z}_q \right\}_{i=1…n,k=1…K}$。</li>
<li><strong>System PK</strong>. $Y_0=e(g,g)^{y_0}$。</li>
</ol>
<h6 id="Attribute-Authority-k-1"><a href="#Attribute-Authority-k-1" class="headerlink" title="Attribute Authority $k$"></a>Attribute Authority $k$</h6><ol>
<li><strong>Authority Secret Key</strong>. $s_k, t_{k,1},…,t_{k,n}$。</li>
<li><strong>Authority Public Key</strong>. $T_{k,1}, …,T_{k,n}$，其中$T_{k,i}=g^{t_{k,i}}$。</li>
<li><strong>Secret Key for User $u$ from authority $k$</strong>. 令$y_{k,u}=F_{s_k}(u)$，其中$F$为伪随机函数。选择$d-1$阶多项式$p$，其中$p(0)=y_{k,u}$。用户私钥为：$\left\{ D_{k,i} = g^{p(i)/t_{k,i}} \right\}_{\forall i \in \mathcal{A}_u}$ 。</li>
</ol>
<h6 id="Central-Authority"><a href="#Central-Authority" class="headerlink" title="Central Authority"></a>Central Authority</h6><ol>
<li><strong>Central  Authority Secret Key</strong> 所有属性机构$k$的种子$s_k$，$y_0$。</li>
<li><strong>Secret Key for User $u$</strong> 对于所有的属性机构$k$，令$y_{k,u}=F_{s_k}(u)$。私钥：$D_{CA}=g^{y_0-\sum _{k=0}^Ky_{k,u}}$。</li>
</ol>
<h6 id="Encryption-for-attribute-set-mathcal-A-C-1"><a href="#Encryption-for-attribute-set-mathcal-A-C-1" class="headerlink" title="Encryption for attribute set $\mathcal{A}_C$"></a>Encryption for attribute set $\mathcal{A}_C$</h6><p>选择随机数$s \in \mathbb{Z}_p$，计算$E=Y_0^sm$，$E_{CA}=g^s$以及$\left\{E_{k,i}=T_{k,i}^s \right\}_{\forall i \in \mathcal{A}_C^k,\forall k}$。</p>
<h6 id="Decryption-4"><a href="#Decryption-4" class="headerlink" title="Decryption"></a>Decryption</h6><p>对于每个属性机构$k$，针对$d$个属性$i$，其中$i$满足$i \in \mathcal{A}_C^k \cap \mathcal{A}_u$，计算$e(E_{k,i}, D_{k,i})=e(g,g)^{p(i)s}$，通过插值得到$Y_{k,u}^s=e(g,g)^{p(0)s}=e(g,g)^{y_{k,u}s}$。对于每个属性机构$k$，计算$Y_{CA}^s=e(E_{CA},D_{CA})$。进而得到$Y_{CA}^s \cdot \prod _{k=1}^K Y_k^s = Y_0^s$，然后$m=E/Y_0^s$。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上根据Chase的论文，一步步引导，最终得到MA-ABE的完整构造。从这一路引导可以看出，为了解决密钥托管的问题，MA-ABE的核心思想是将一个KGC分裂成多个不需要“沟通”的多个权威机构，而构造中又遇到了共谋攻击问题，为了解决这个问题，引入了全局GID的概念，而将此概念运用到方案中又出现方案“协调性”问题，是引入全局可信中心机构CA来解决的。从整体上讲，我们可以发现，MA-ABE是FIBE的多层次拓展，FIBE只是运用一次拉格朗日插值，而MA-ABE可以看作是两层插值。MA-ABE为多个权威机构的ABE方案开辟了先河，而GID的概念也是广泛运用到后续的研究中。然而MA-ABE还是有一个全局可信的CA存在，实质上还是没有解决密钥托管的问题，Chase<sup><a href="ref2">2</a></sup>在后续的文章中有继续关注这个问题。</p>
<p><span name="ref1">M. Chase, “Multi-authority attribute based encryption,” in Proc. TCC’07, 2007, pp. 515–534, Springer.</span></p>
<p><span name="ref2">M. Chase and S.S. M.Chow,“Improvingprivacy andsecurity in multi-authority attribute-based encryption,” in Proc. CCS’09, 2009, pp. 121–130, ACM.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>共谋攻击</tag>
        <tag>多个属性机构</tag>
      </tags>
  </entry>
  <entry>
    <title>O-ABE</title>
    <url>/2021/04/14/O-ABE/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>前面的几篇文章都关注在密钥托管、属性撤销以及共谋攻击这几个方面。诚然这些方面是设计ABE算法时需要考虑的地方。我们现在回想一下前面介绍的这些ABE方案，其中不管是基于什么难题，异或是访问结构是访问控制树还是线性秘密共享方案，所构造的ABE方案都有一个共同的特点，那就是解密所需要的操作数量与密文中属性个数成正比。这也就意味着，密文中的属性越多，解密的操作数就越多。而对于一些存储计算资源受限的设备，就无法胜任解密的工作。</p>
<span id="more"></span>
<p>Green和Waters<sup><a href="ref1">1</a></sup>（对，还是那个大佬）为了减轻用户端解密的开销，首次提出了外包ABE的原型（这也是本文取名O-ABE的原因）。方案的设想是，用户在解密的时候，不将全部的操作由自己来弄，而是将绝大部分的工作量委托给第三方代理，让第三方算出大部分的结果之后再返回结果，而用户实际的计算将会很少。设想是美好的，但是这其中有一个问题，那就是第三方如何能帮你计算出有效的部分结果，而这个结果对于他而言，完全不能得到密文有关的任何信息。</p>
<p>那么O-ABE是如何做到既能外包大部分操作，又能保证密文的安全性呢？答案是方案中用到了所谓的“盲化”技术，即在由KGC生成用户私钥之后，用户是可以拿着私钥解密密文的，但是碍于操作量大，用户可能无法完成，因此他将自己的私钥运用“盲化“技术衍生为一个转换密钥，而第三方机构正是由这个密钥算得解密的一部分。而这个转换密钥在对于第三方机构来说一点帮助都没有，解密之后也看不到明文是什么样的。下面看看O-ABE具体是怎样构造的吧！</p>
<h4 id="具体构造"><a href="#具体构造" class="headerlink" title="具体构造"></a>具体构造</h4><h5 id="Setup-lambda-U"><a href="#Setup-lambda-U" class="headerlink" title="Setup($\lambda,U$)"></a><strong>Setup($\lambda,U$)</strong></h5><p>Setup算法将系统的安全参数$\lambda$和系统属性域$U$作为输入。选择一个$p$阶乘法循环群$\mathbb{G}$，生成元为$g$，选择一个哈希函数$F$将$\left\{0,1\right\}^+$映射到$\mathbb{G}$。选择指数$\alpha, a \in \mathbb{Z}_p$。系统的主密钥为$MSK=(g^\alpha,a)$，系统的公共参数为$PK=(g,e(g,g)^\alpha, g^a,F)$。</p>
<h5 id="Encrypt-PK-mathcal-M-M-rho"><a href="#Encrypt-PK-mathcal-M-M-rho" class="headerlink" title="Encrypt($PK,\mathcal{M},(M,\rho)$)"></a><strong>Encrypt($PK,\mathcal{M},(M,\rho)$)</strong></h5><p>Encrypt算法将$PK$和消息$\mathcal{M}$作为输入。选择一个线性秘密共享方案的访问结构$(M,\rho)$，函数$\rho$将矩阵$M \in \mathbb{Z}_p^{l\times n}$的每一行映射到一个属性。选择随机向量$\overrightarrow{v}=(s,v_2,…,v_n) \in \mathbb{Z}_p^n$，$\forall i \in [l]$，计算$\lambda _i = \overrightarrow{v}M_i$，其中$M_i$为矩阵$M$的第$i$行。随机选择$r_1,…,r_l \in \mathbb{Z}_p$，然后加密$\mathcal{M}$得到密文为</p>
<script type="math/tex; mode=display">
\begin{aligned}
C=((M, \rho), \mathcal{M} \cdot e(g,g)^{\alpha s}, C^ \prime =g^s, \nonumber \\
\forall i \in [l]； C_i=g^{a\lambda_i} \cdot F(\rho(i))^{-r_i},D_i=g^{r_i}). \nonumber
\end{aligned}</script><h5 id="KeyGen-MSK-S"><a href="#KeyGen-MSK-S" class="headerlink" title="KeyGen($MSK,S$)"></a><strong>KeyGen($MSK,S$)</strong></h5><p>KeyGen算法将$MSK$和用户的属性集合$S$作为输入。首先选择随机数$t^\prime$，然后得到密钥</p>
<script type="math/tex; mode=display">
SK^\prime = (K^\prime = g^\alpha g^{at^\prime},L^\prime = g^{t^\prime},
\left\{ K_x^\prime = F(x)^{t^\prime} \right\}_{x \in S}).</script><p>然后选择随机数$z \in \mathbb{Z}_p$，设置转换密钥为</p>
<script type="math/tex; mode=display">
TK = (K={K^\prime}^{1/z} = g^{(\alpha /z)} g^{a(t^\prime/z)}=g^{(\alpha /z)}g^{at},L={L^\prime}^{1/z} = g^{t^\prime /z} = g^t,
\left\{ K_x \right\}_{x \in S}=\left\{ {K_x^\prime}^{1/z} \right\}_{x \in S}).</script><p>用户私钥为$SK=(z,TK)$。</p>
<h5 id="Transform-TK-CT"><a href="#Transform-TK-CT" class="headerlink" title="Transform($TK,CT$)"></a><strong>Transform($TK,CT$)</strong></h5><p>Transfrom算法输入转换密钥$TK=(K,L,\left\{  K_x\right\}_{x \in S})$和密文$CT=(C,C^\prime, \left\{ C_i, D_i\right\}_{i \in [l]})$。如果$S$不满足访问结构，那么直接输出$\perp $。如果$S$满足访问结构，定义索引集合$I \sqsubset \left\{1,2…,l \right\}$为$I=\left\{ i:\rho(i) \in S \right\}$。然后存在一系列的常数$\left\{\omega_i \in \mathbb{Z}_p \right\}_{i \in I}$使得$\sum_{i \in I}\omega_i \lambda_i=s$。然后计算</p>
<script type="math/tex; mode=display">
\begin{aligned}
&e(C^\prime,K)/( (e(\prod _{i \in I} C_i^{\omega _i},L) \prod _{i \in I} e(D_i^{\omega _i},K_{\rho(i)})))= \nonumber\\
&e(g,g)^{\alpha s /z}e(g,g)^{ast}/( \prod _{i \in I} e(g,g)^{ta\lambda _i \omega _i})=e(g,g)^{\alpha s /z} \nonumber
\end{aligned}</script><p>然后输出半解密的密文$CT^\prime=(C,e(g,g)^{\alpha s /z})$。</p>
<h5 id="Decrypt-SK-CT"><a href="#Decrypt-SK-CT" class="headerlink" title="Decrypt($SK,CT$)"></a><strong>Decrypt($SK,CT$)</strong></h5><p>Decrypt算法输入用户私钥$SK=(z,TK)$和密文$CT$。如果密文没有半解密，那么将调用Transfrom算法，如果Transfrom算法输出$\perp$，则Decrypt算法输出$\perp$。否则，用户会拿到半解密密文$(T_0.T_1)$，解密只需计算$T_0/T_1^z=\mathcal{M}$。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实我们通过O-ABE算法的构造会发现，其中大部分步骤和Waters的2SPSR方案中的第一个是差不多的，只不过多了密文转换Transfrom这个步骤。该外包ABE的实现运用的盲化的技巧，首先KGC会为用户生成正确的密钥，然后用户随机选择一个秘密值来“随机化自己的私钥”，称之为转换密钥，将此密钥发送给第三方委托半解密密文，用户最终得到的密文已经“很短”了，只需要常数级别的操作即可恢复出密文，这便是外包ABE的大体思路。O-ABE为减小密文解密开销提供了一种技巧，这种技巧广泛地被运用到ABE方案的构建上，后边要介绍的DAC-MACS<sup><a href="ref2">2</a></sup>便运用了这一技巧。</p>
<p><span name="ref1">M. Green, S. Hohenberger, and B. Waters, “Outsourcing the Decryption of ABE Ciphertexts,” in <em>Proceedings of the 20th USENIX conference on Security</em>, San Francisco, CA, USA, 2011.</span></p>
<p><span name="ref1">K. Yang, X. H. Jia, K. Ren, B. Zhang, and R. T. Xie, “DAC-MACS: Effective Data Access Control for Multi-authority Cloud Storage Systems,” <em>IEEE Transactions on Information Forensics and Security</em>, vol. 8, no.11, pp. 1790-1801, Nov. 2013.</span>&gt;</p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>外包解密</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和有关</title>
    <url>/2021/11/08/%E5%89%8D%E7%BC%80%E5%92%8C%E6%9C%89%E5%85%B3/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文介绍前缀和有关问题，包括连续数组、连续子数组和、和为k的子数组、矩阵区域和、元素和小于等于阈值的正方形的最大边长、检查是否区域内所有整数都被覆盖、字母和数字。</p>
<span id="more"></span>
<h4 id="连续数组1"><a href="#连续数组1" class="headerlink" title="连续数组1"></a>连续数组<sup><a href="ref1">1</a></sup></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
<p><strong>示例输入</strong>：<code>nums = [0,1,0]</code></p>
<p><strong>示例输出</strong>：<code>2</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前缀和加哈希</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=nums.length;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">        map.put(count,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="number">1</span>) count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(count))&#123;</span><br><span class="line">                <span class="keyword">int</span> preIndex=map.get(count);</span><br><span class="line">                maxLen=Math.max(maxLen,i-preIndex);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(count,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="连续子数组和2"><a href="#连续子数组和2" class="headerlink" title="连续子数组和2"></a>连续子数组和<sup><a href="ref2">2</a></sup></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code> 和一个整数<code>k</code>，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>
<ul>
<li><p>子数组大小 至少为 <code>2</code>，且</p>
</li>
<li><p>子数组元素总和为 <code>k</code>的倍数。 </p>
<p>如果存在，返回<code>true</code> ；否则，返回 <code>false</code> 。</p>
</li>
</ul>
<p>如果存在一个整数<code>n</code>，令整数<code>x</code>符合 <code>x = n * k</code>，则称 <code>x</code> 是 <code>k</code>的一个倍数。<code>0</code>始终视为 <code>k</code> 的一个倍数。</p>
<p><strong>示例输入</strong>：<code>nums = [23,2,4,6,7], k = 6</code></p>
<p><strong>示例输出</strong>：<code>true</code></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前缀和加哈希</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum[]=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;sum[i]=sum[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];&#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//此处应从0开始</span></span><br><span class="line">        <span class="comment">//sum[i]-sum[j]表示nums数组从j+1到i的数之和</span></span><br><span class="line">        <span class="comment">//若从1开始，则相当于没有考虑第一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum[i]%k))&#123;<span class="keyword">if</span>(i-map.get(sum[i]%k)&gt;<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;map.put(sum[i]%k,i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="和为k的子数组3"><a href="#和为k的子数组3" class="headerlink" title="和为k的子数组3"></a>和为k的子数组<sup><a href="ref3">3</a></sup></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<p><strong>示例输入</strong>：<code>nums = [1,2,3], k = 3</code></p>
<p><strong>示例输出</strong>：<code>2</code></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前缀和加哈希</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int len = nums.length;</span></span><br><span class="line">        <span class="comment">// 计算前缀和数组</span></span><br><span class="line">        <span class="comment">// int[] preSum = new int[len + 1];</span></span><br><span class="line">        <span class="comment">// preSum[0] = 0;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     preSum[i + 1] = preSum[i] + nums[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int count = 0;</span></span><br><span class="line">        <span class="comment">// for (int left = 0; left &lt; len; left++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int right = left; right &lt; len; right++) &#123;</span></span><br><span class="line">        <span class="comment">//         // 区间和 [left..right]，注意下标偏移</span></span><br><span class="line">        <span class="comment">//         if (preSum[right + 1] - preSum[left] == k) &#123;</span></span><br><span class="line">        <span class="comment">//             count++;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return count;</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            preSum+=num;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(preSum-k))&#123;</span><br><span class="line">                count+=map.get(preSum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(preSum,map.getOrDefault(preSum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵区域和4"><a href="#矩阵区域和4" class="headerlink" title="矩阵区域和4"></a>矩阵区域和<sup><a href="ref4">4</a></sup></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个 <code>m x n</code>的矩阵 <code>mat</code> 和一个整数 <code>k</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个<code>answer[i][j]</code>是所有满足下述条件的元素 <code>mat[r][c]</code>的和： </p>
<ul>
<li><code>i - k &lt;= r &lt;= i + k</code>,</li>
<li><code>j - k &lt;= c &lt;= j + k</code> 且</li>
<li><code>(r, c)</code>在矩阵内。</li>
</ul>
<p><strong>示例输入</strong>：<code>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2</code></p>
<p><strong>示例输出</strong>：<code>[[45,45,45],[45,45,45],[45,45,45]]</code></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] matrixBlockSum(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=mat.length,m=mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]+mat[i-<span class="number">1</span>][j-<span class="number">1</span>]-dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1=i-k,y1=j-k,x2=i+k,y2=j+k;</span><br><span class="line">                <span class="keyword">if</span>(x1&lt;<span class="number">1</span>) x1=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(y1&lt;<span class="number">1</span>) y1=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x2&gt;n) x2=n;</span><br><span class="line">                <span class="keyword">if</span>(y2&gt;m) y2=m;</span><br><span class="line">                mat[i-<span class="number">1</span>][j-<span class="number">1</span>]=dp[x2][y2]+dp[x1-<span class="number">1</span>][y1-<span class="number">1</span>]-dp[x1-<span class="number">1</span>][y2]-dp[x2][y1-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="元素和小于等于阈值的正方形的最大边长5"><a href="#元素和小于等于阈值的正方形的最大边长5" class="headerlink" title="元素和小于等于阈值的正方形的最大边长5"></a>元素和小于等于阈值的正方形的最大边长<sup><a href="ref5">5</a></sup></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个大小为<code>m x n</code>的矩阵 <code>mat</code> 和一个整数阈值 <code>threshold</code>。</p>
<p>请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回<code>0</code> 。</p>
<p><strong>示例输入</strong>：<code>mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4</code></p>
<p><strong>示例输出</strong>：<code>2</code></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSideLength</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = mat[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= Math.min(m, n); k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - k &lt; <span class="number">0</span> || j - k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> tmp = dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k];</span><br><span class="line">                    <span class="keyword">if</span> (tmp &lt;= threshold) &#123;</span><br><span class="line">                        ans = Math.max(ans, k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="检查是否区域内所有整数都被覆盖6"><a href="#检查是否区域内所有整数都被覆盖6" class="headerlink" title="检查是否区域内所有整数都被覆盖6"></a>检查是否区域内所有整数都被覆盖<sup><a href="ref6">6</a></sup></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个二维整数数组 <code>ranges</code>和两个整数 <code>left</code>和 <code>right</code> 。每个<code>ranges[i] = [starti, endi]</code> 表示一个从<code>starti</code>到 <code>endi</code>的 闭区间 。</p>
<p>如果闭区间<code>[left, right]</code> 内每个整数都被<code>ranges</code> 中 至少一个 区间覆盖，那么请你返回 <code>true</code> ，否则返回 <code>false</code>。</p>
<p>已知区间<code>ranges[i] = [starti, endi]</code> ，如果整数<code>x</code>满足<code>starti &lt;= x &lt;= endi</code> ，那么我们称整数<code>x</code> 被覆盖了。</p>
<p><strong>示例输入</strong>：<code>ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5</code></p>
<p><strong>示例输出</strong>：<code>true</code></p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//差分加前缀和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCovered</span><span class="params">(<span class="keyword">int</span>[][] ranges, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">52</span>];   <span class="comment">// 差分数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] range : ranges) &#123;</span><br><span class="line">            ++diff[range[<span class="number">0</span>]];</span><br><span class="line">            --diff[range[<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; ++i) &#123;</span><br><span class="line">            curr += diff[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= left &amp;&amp; i &lt;= right &amp;&amp; curr &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="字母和数字7"><a href="#字母和数字7" class="headerlink" title="字母和数字7"></a>字母和数字<sup><a href="ref7">7</a></sup></h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>
<p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>
<p><strong>示例输入</strong>：<br><code>[&quot;A&quot;,&quot;1&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;E&quot;,&quot;5&quot;,&quot;F&quot;,&quot;G&quot;,&quot;6&quot;,&quot;7&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;]</code></p>
<p><strong>示例输出</strong>：<br><code>[&quot;A&quot;,&quot;1&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;E&quot;,&quot;5&quot;,&quot;F&quot;,&quot;G&quot;,&quot;6&quot;,&quot;7&quot;]</code></p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; left = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; right = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;left.put(count, -<span class="number">1</span>);list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = array[i].charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>)count++;<span class="keyword">else</span> count--;</span><br><span class="line">            <span class="keyword">if</span>(left.containsKey(count))right.put(count, i);</span><br><span class="line">            <span class="keyword">else</span>&#123;left.put(count, i);list.add(count);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>,start = <span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer i:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!right.containsKey(i))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> s = left.get(i), e = right.get(i);</span><br><span class="line">            <span class="keyword">if</span>(e-s&gt;maxLength)&#123;maxLength = e-s;start = s+<span class="number">1</span>;end = e;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxLength == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        String [] ret = <span class="keyword">new</span> String[maxLength];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start,j=<span class="number">0</span>;i&lt;=end;i++,j++)ret[j]=array[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/contiguous-array/">https://leetcode-cn.com/problems/contiguous-array/</a></span></p>
<p><span name="ref2"><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">https://leetcode-cn.com/problems/continuous-subarray-sum/</a></span></p>
<p><span name="ref3"><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></span></p>
<p><span name="ref4"><a href="https://leetcode-cn.com/problems/matrix-block-sum/">https://leetcode-cn.com/problems/matrix-block-sum/</a></span></p>
<p><span name="ref5"><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/">https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/</a></span></p>
<p><span name="ref6"><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/</a></span></p>
<p><span name="ref7"><a href="https://leetcode-cn.com/problems/find-longest-subarray-lcci/">https://leetcode-cn.com/problems/find-longest-subarray-lcci/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2021/08/04/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文介绍十大排序算法。</p>
<span id="more"></span>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非线性时间比较</span></span><br><span class="line"><span class="comment">//          交换排序</span></span><br><span class="line"><span class="comment">//                  冒泡排序</span></span><br><span class="line"><span class="comment">//                  快速排序</span></span><br><span class="line"><span class="comment">//          插入排序</span></span><br><span class="line"><span class="comment">//                  简单插入</span></span><br><span class="line"><span class="comment">//                  希尔排序</span></span><br><span class="line"><span class="comment">//          选择排序</span></span><br><span class="line"><span class="comment">//                  简单选择</span></span><br><span class="line"><span class="comment">//                  堆排序</span></span><br><span class="line"><span class="comment">//          归并排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性时间比较</span></span><br><span class="line"><span class="comment">//          基数排序</span></span><br><span class="line"><span class="comment">//          计数排序</span></span><br><span class="line"><span class="comment">//          桶排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不稳定</span></span><br><span class="line"><span class="comment">//          选择、堆、希尔、快速</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是按照升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Symbol</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Symbol</span><span class="params">(<span class="keyword">int</span> vlaue, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = vlaue;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> +</span><br><span class="line">                    value +</span><br><span class="line">                    <span class="string">&quot;, &quot;</span> + index +</span><br><span class="line">                    <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SortUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、冒泡排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(Symbol[] source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = source.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (source[j].value &gt; source[j + <span class="number">1</span>].value) &#123;</span><br><span class="line">                    Symbol tmp = source[j + <span class="number">1</span>];</span><br><span class="line">                    source[j + <span class="number">1</span>] = source[j];</span><br><span class="line">                    source[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(Symbol[] source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = source.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; l; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (source[j].value &lt; source[minIndex].value)</span><br><span class="line">                    minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            Symbol tmp = source[minIndex];</span><br><span class="line">            source[minIndex] = source[i];</span><br><span class="line">            source[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Symbol[] source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = source.length;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; i++) &#123;</span><br><span class="line">            Symbol tmp = source[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp.value &lt; source[j].value) &#123;</span><br><span class="line">                source[j + <span class="number">1</span>] = source[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            source[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, Symbol[] source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        Symbol base;</span><br><span class="line">        i = left;</span><br><span class="line">        j = right;</span><br><span class="line">        base = source[left];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (source[j].value &gt;= base.value &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (source[i].value &lt;= base.value &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                Symbol tmp = source[i];</span><br><span class="line">                source[i] = source[j];</span><br><span class="line">                source[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source[left] = source[i];</span><br><span class="line">        source[i] = base;</span><br><span class="line">        quickSort(left, i - <span class="number">1</span>, source);</span><br><span class="line">        quickSort(i + <span class="number">1</span>, right, source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(Symbol[] source, <span class="keyword">int</span> i, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; l &amp;&amp; source[left].value &gt; source[largest].value) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; l &amp;&amp; source[right].value &gt; source[largest].value) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            Symbol tmp = source[largest];</span><br><span class="line">            source[largest] = source[i];</span><br><span class="line">            source[i] = tmp;</span><br><span class="line">            heapify(source, largest, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(Symbol[] source, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(source, i, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(Symbol[] source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = source.length;</span><br><span class="line">        buildMaxHeap(source, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Symbol tmp = source[<span class="number">0</span>];</span><br><span class="line">            source[<span class="number">0</span>] = source[i];</span><br><span class="line">            source[i] = tmp;</span><br><span class="line">            l--;</span><br><span class="line">            heapify(source, <span class="number">0</span>, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、希尔排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(Symbol[] source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = source.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = l; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; l; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                Symbol cur = source[i];</span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; cur.value &lt; source[j - gap].value) &#123;</span><br><span class="line">                    source[j] = source[j - gap];</span><br><span class="line">                    j = j - gap;</span><br><span class="line">                &#125;</span><br><span class="line">                source[j] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Symbol[] source, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(source, start, mid);</span><br><span class="line">            mergeSort(source, mid + <span class="number">1</span>, end);</span><br><span class="line">            mergeSortHelper(source, start, mid, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortHelper</span><span class="params">(Symbol[] source, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start1;</span><br><span class="line">        <span class="keyword">int</span> j = start2;</span><br><span class="line">        List&lt;Symbol&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= end1 &amp;&amp; j &lt;= end2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source[i].value &lt;= source[j].value) &#123;</span><br><span class="line">                list.add(source[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(source[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= end1) &#123;</span><br><span class="line">            list.add(source[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end2) &#123;</span><br><span class="line">            list.add(source[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = start1; p &lt;= end2; p++) &#123;</span><br><span class="line">            source[p] = list.get(p - start1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8、计数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] source) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = source.length;</span><br><span class="line">        <span class="keyword">int</span> Max = source[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> Min = source[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            Max = Math.max(Max, source[i]);</span><br><span class="line">            Min = Math.min(Min, source[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[Max - Min + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            tmp[source[i] - Min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Max - Min; i++) &#123;</span><br><span class="line">            tmp[i] += tmp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[tmp[source[i] - Min] - <span class="number">1</span>] = source[i];</span><br><span class="line">            tmp[source[i] - Min]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxBit</span><span class="params">(<span class="keyword">int</span>[] source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (source[i] &gt;= cur) &#123;</span><br><span class="line">                cur *= <span class="number">10</span>;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9、基数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] source) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = maxBit(source);</span><br><span class="line">        <span class="keyword">int</span> l = source.length;</span><br><span class="line">        <span class="keyword">int</span> radix = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">                k = (source[j] / radix) % <span class="number">10</span>;</span><br><span class="line">                count[k]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                count[j] += count[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = l - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                k = (source[j] / radix) % <span class="number">10</span>;</span><br><span class="line">                tmp[count[k] - <span class="number">1</span>] = source[j];</span><br><span class="line">                count[k]--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.arraycopy(tmp, <span class="number">0</span>, source, <span class="number">0</span>, l);</span><br><span class="line">            radix *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10、桶排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] source) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, source[i]);</span><br><span class="line">            min = Math.min(min, source[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//桶数</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / source.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将每个元素放入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (source[i] - min) / (source.length);</span><br><span class="line">            bucketArr.get(num).add(source[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++) &#123;</span><br><span class="line">                source[k++] = bucketArr.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] test = &#123;<span class="number">1</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">22</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">22</span>&#125;;</span><br><span class="line">        Symbol[] symbols = <span class="keyword">new</span> Symbol[test.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; symbols.length; i++) &#123;</span><br><span class="line">            symbols[i] = <span class="keyword">new</span> Symbol(test[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//SortUtil.bubbleSort(symbols);</span></span><br><span class="line">        <span class="comment">// [(1, 0), (5, 3), (6, 4), (8, 5), (9, 9), (14, 2), (22, 1), (22, 8), (22, 10), (22, 11), (34, 6), (43, 7)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SortUtil.selectSort(symbols);</span></span><br><span class="line">        <span class="comment">// [(1, 0), (5, 3), (6, 4), (8, 5), (9, 9), (14, 2), (22, 8), (22, 1), (22, 10), (22, 11), (34, 6), (43, 7)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SortUtil.insertSort(symbols);</span></span><br><span class="line">        <span class="comment">// [(1, 0), (5, 3), (6, 4), (8, 5), (9, 9), (14, 2), (22, 1), (22, 8), (22, 10), (22, 11), (34, 6), (43, 7)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SortUtil.quickSort(0,symbols.length-1,symbols);</span></span><br><span class="line">        <span class="comment">// [(1, 0), (5, 3), (6, 4), (8, 5), (9, 9), (14, 2), (22, 1), (22, 11), (22, 8), (22, 10), (34, 6), (43, 7)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SortUtil.heapSort(symbols);</span></span><br><span class="line">        <span class="comment">// [(1, 0), (5, 3), (6, 4), (8, 5), (9, 9), (14, 2), (22, 11), (22, 10), (22, 8), (22, 1), (34, 6), (43, 7)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SortUtil.shellSort(symbols);</span></span><br><span class="line">        <span class="comment">// [(1, 0), (5, 3), (6, 4), (8, 5), (9, 9), (14, 2), (22, 1), (22, 10), (22, 8), (22, 11), (34, 6), (43, 7)]</span></span><br><span class="line"></span><br><span class="line">        SortUtil.mergeSort(symbols, <span class="number">0</span>, symbols.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(symbols));</span><br><span class="line">        <span class="comment">// [(1, 0), (5, 3), (6, 4), (8, 5), (9, 9), (14, 2), (22, 1), (22, 8), (22, 10), (22, 11), (34, 6), (43, 7)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(SortUtil.countSort(test)));</span></span><br><span class="line">        <span class="comment">// [1, 5, 6, 8, 9, 14, 22, 22, 22, 22, 34, 43]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(SortUtil.radixSort(test)));</span></span><br><span class="line">        <span class="comment">// [1, 5, 6, 8, 9, 14, 22, 22, 22, 22, 34, 43]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(SortUtil.bucketSort(test)));</span><br><span class="line">        <span class="comment">// [1, 5, 6, 8, 9, 14, 22, 22, 22, 22, 34, 43]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序和桶排序解决问题</title>
    <url>/2021/11/08/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文介绍用堆排序和桶排序解决的有关问题，包括存在重复元素、前k个高频元素和前k个高频单词。</p>
<span id="more"></span>
<h4 id="重复元素1"><a href="#重复元素1" class="headerlink" title="重复元素1"></a>重复元素<sup><a href="ref1">1</a></sup></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组<code>nums</code> 和两个整数<code>k</code>和 <code>t</code>。请你判断是否存在 两个不同下标 <code>i</code>和<code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code>，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p>
<p>如果存在则返回 <code>true</code>，不存在返回<code>false</code>。</p>
<p><strong>示例输入</strong>：<code>nums = [1,0,1,1], k = 1, t = 2</code></p>
<p><strong>示例输出</strong>：<code>true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">         <span class="comment">/*  abs(nums[i] - nums[j]) &lt;= t，假设t = 2，则差的绝对值可以是0，1，2</span></span><br><span class="line"><span class="comment">            因此坐标计算 inx， 当 x &gt;= 0 ： x / (t + 1)</span></span><br><span class="line"><span class="comment">                            当 x &lt; 0：( x + 1 ) / (t + 1) - 1</span></span><br><span class="line"><span class="comment">            为了把某（t + 1）个数正确映射到某个容量范围的桶</span></span><br><span class="line"><span class="comment">            如 0， 1， 2，除以容量3，得到 0</span></span><br><span class="line"><span class="comment">            而 -1， -2， -3 除以3则有-1和0，出现错误，因此，</span></span><br><span class="line"><span class="comment">            把负数统一加一得到 0，-1，-2， 此时除以3是0，也出错，但若再减一则是-1，正确</span></span><br><span class="line"><span class="comment">            abs (i - j) &lt;= k是桶的数量，即坐标差绝对值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> size = t + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//桶容量</span></span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> x = nums[i];</span><br><span class="line">            <span class="keyword">long</span> inx = getInx(x, size);</span><br><span class="line">            <span class="comment">//由上述方法计算的桶坐标</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(inx)) &#123;</span><br><span class="line">                <span class="comment">//当桶坐标存在，说明已经有此桶范围内的数，满足题意，</span></span><br><span class="line">                <span class="comment">// 差值绝对值 &lt;= t，坐标差值为0，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(inx, x);            </span><br><span class="line">            <span class="keyword">long</span> l = inx - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> r = inx + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//左右桶</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(l) &amp;&amp; x - map.get(l) &lt;= t) &#123;</span><br><span class="line">                <span class="comment">//根据算法，左边数肯定小于右边数，因此调整减数与被减数，无需绝对值</span></span><br><span class="line">                <span class="comment">//左桶存在，说明在2t范围内 [0, 2t]可能有 [0,t]差值的数，于是相减判断，若有则返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(r) &amp;&amp; map.get(r) - x &lt;= t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//右桶桶左桶</span></span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                <span class="comment">//桶数量，因为 i 从0递增，当 i == k - 1时刚好k个桶，坐标差绝对值符合题意，大于等于则不符合题意，</span></span><br><span class="line">                <span class="comment">//需要将最左边，即数组坐标为i - k的数所在的桶移除</span></span><br><span class="line">                map.remove(map.remove(getInx((<span class="keyword">long</span>)nums[i - k], size)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//遍历结束仍没有找到，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getInx</span> <span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x / size : (x + <span class="number">1</span>) / size - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前k个高频元素2"><a href="#前k个高频元素2" class="headerlink" title="前k个高频元素2"></a>前k个高频元素<sup><a href="ref2">2</a></sup></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例输入</strong>：<code>nums = [1,1,1,2,2,3], k = 2</code></p>
<p><strong>示例输出</strong>：<code>[1,2]</code></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] m, <span class="keyword">int</span>[] n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> m[<span class="number">1</span>] - n[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey(), count = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek()[<span class="number">1</span>] &lt; count) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ret[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前k个高频单词3"><a href="#前k个高频单词3" class="headerlink" title="前k个高频单词3"></a>前k个高频单词<sup><a href="ref3">3</a></sup></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>
<p><strong>示例输入</strong>：<code>[&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</code></p>
<p><strong>示例输出</strong>：<code>[&quot;i&quot;, &quot;love&quot;]</code></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt.get(word1) == cnt.get(word2) ? word1.compareTo(word2) : cnt.get(word2) - cnt.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">https://leetcode-cn.com/problems/contains-duplicate-iii/</a></span></p>
<p><span name="ref2"><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></span></p>
<p><span name="ref3"><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">https://leetcode-cn.com/problems/top-k-frequent-words/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2021/05/18/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>字符串是程序中最常见的一种数据类型之一，是由零个或多个字符组成的有限序列。本文介绍与字符串有关的一些操作，包括字符串转整数<sup><a href="ref1">1</a></sup>、字符串压缩<sup><a href="ref2">2</a></sup>、字符串相加<sup><a href="ref3">3</a></sup>相乘<sup><a href="ref4">4</a></sup>、两字符串的最长公共子串以及两字符串的最长公共子序列<sup><a href="ref5">5</a></sup>。<br><span id="more"></span></p>
<h4 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>实现函数<code>myAtoi(string s)​</code>的算法，要求如下：</p>
<ul>
<li>读入字符串并丢弃无用的前导空格。</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，<code>&quot;123&quot; -&gt; 123</code>，<code>&quot;0032&quot; -&gt; 32</code>）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 $[−2^{31},  2^{31} − 1]$ ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $−2^{31}$ 的整数应该被固定为 $−2^{31}$ ，大于$ 2^{31} − 1$ 的整数应该被固定为 $2^{31} − 1$ 。</li>
<li>返回整数作为最终结果。</li>
</ul>
<h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>这个题目的要求比较细，每一种情况都需要覆盖。首先去除无用的前导空格，可以将字符串转换为char数组，然后跳过前面的空格。然后针对第一个有效字符，设置默认的符号为正，如果第一个有效字符为<code>&#39;-&#39;</code>，则设置为负数，如果是<code>&#39;+&#39;</code>或者直接是数字则为默认正数。对于当前索引$i$字符，如果不在<code>&#39;0&#39;-&#39;9&#39;</code>之间，则只转换该索引之前的字符。最后需要保证转换的数在<code>int</code>范围内，因为是通过一个<code>res</code>变量从前到后计算保留当前索引处的转换结果，因此，每次比较<code>res &gt; Integer.MAX_VALUE / 10</code>（<code>res&gt;214748364</code>，<code>Integer.MAX_VALUE=2147483647</code>）或者 (<code>res == Integer.MAX_VALUE / 10 &amp;&amp; (currChar - &#39;0&#39;) &gt; Integer.MAX_VALUE % 10</code>（<code>2147483650&gt;res&gt;2147483647</code>），如果满足条件，则在下一轮乘以10后将超过<code>Integer.MAX_VALUE</code>，负数的情况类似。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="comment">// str.charAt(i) 方法回去检查下标的合法性，一般先转换成字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="comment">// 1、去除前导空格</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len &amp;&amp; charArray[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、如果已经遍历完成（针对极端用例 &quot;      &quot;）</span></span><br><span class="line">    <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、如果出现符号字符，仅第 1 个有效，并记录正负</span></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> firstChar = charArray[index];</span><br><span class="line">    <span class="keyword">if</span> (firstChar == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        sign = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、将后续出现的数字字符进行转换</span></span><br><span class="line">    <span class="comment">// 不能使用 long 类型，这是题目说的</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> currChar = charArray[index];</span><br><span class="line">        <span class="comment">// 4.1 先判断不合法的情况</span></span><br><span class="line">        <span class="keyword">if</span> (currChar &gt; <span class="string">&#x27;9&#x27;</span> || currChar &lt; <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 题目中说：环境只能存储 32 位大小的有符号整数，因此，需要提前判：断乘以 10 以后是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">&#x27;0&#x27;</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">&#x27;0&#x27;</span>) &gt; -(Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.2 合法的情况下，才考虑转换，每一步都把符号位乘进去</span></span><br><span class="line">            res = res * <span class="number">10</span> + sign * (currChar - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串压缩"><a href="#字符串压缩" class="headerlink" title="字符串压缩"></a>字符串压缩</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（<code>a</code>至<code>z</code>）。</p>
<h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>遍历字符串<code>s</code>，从第一个字符开始记录连续相同的字符个数，将字符和个数拼装进字符串，直到s遍历完全。最后记得比较“压缩”后的字符长度与原字符长度，若长度没有变短，则返回原字符串<code>s</code>。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.length() == <span class="number">0</span>) &#123; <span class="comment">// 空串处理</span></span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = S.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == S.charAt(i)) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.append(ch);</span><br><span class="line">            ans.append(cnt);</span><br><span class="line">            ch = S.charAt(i);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.append(ch);</span><br><span class="line">    ans.append(cnt);</span><br><span class="line">    <span class="keyword">return</span> ans.length() &gt;= S.length() ? S : ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
<h5 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h5><p>模拟两个数的加法过程，从个位开始，再到高位，需要注意的是加的过程中要考虑进位，高位对齐处没有则补领。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = num1.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = num2.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || add != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = i&gt;=<span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j&gt;=<span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = x + y + add;</span><br><span class="line">        s.append(result%<span class="number">10</span>);</span><br><span class="line">        add = result/<span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    s.reverse();</span><br><span class="line">    <span class="keyword">return</span> s.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<h5 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h5><p>模拟两个数的乘法，将<code>num1</code>与<code>num2</code>的第$i$位相乘，相乘的结果需要按照$i$的位置添加<code>&#39;0&#39;</code>，最后将结果相加，可调用字符串相加的函数。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;0&quot;</span>.equals(num1) || <span class="string">&quot;0&quot;</span>.equals(num2)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m = num1.length();</span><br><span class="line">    <span class="keyword">int</span> n = num2.length();</span><br><span class="line">    String ans = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;i; --j)&#123;</span><br><span class="line">            s.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = num2.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m-<span class="number">1</span>; j&gt;=<span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = num1.charAt(j)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = a*b+add;</span><br><span class="line">            s.append(tmp % <span class="number">10</span>);</span><br><span class="line">            add = tmp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(add != <span class="number">0</span>)&#123;</span><br><span class="line">            s.append(add%<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = addStrings(ans, s.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两字符串的最长公共子串"><a href="#两字符串的最长公共子串" class="headerlink" title="两字符串的最长公共子串"></a>两字符串的最长公共子串</h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个字符串<code>str1</code>和<code>str2</code>，返回这两个字符串的最长公共子串，子串是连续的，这需要与子序列相区别。如果不存在，返回<code>“-1”。</code></p>
<h5 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h5><p>如果是返回两字符串的最长公共子串的长度，那么直接用动态规划即可，但是这里需要返回最长公共子串，因此需要在动态规划的基础上，维护一个子串的结束下标<code>end</code>以及子串长度的最大值<code>max</code>。</p>
<p>用动态规划时，明确$dp$数组的含义，这里$dp[i][j]$表示以<code>str1</code>第$i$个字符结尾的字符串与以<code>str2</code>第$j$个字符结尾的字符串的最长公共子串的长度（最后一个字符的索引分别为$i-1$和$j-1$），则当$str1.charAt(i-1)==str2.charAt(j-1)$时，$dp[i][j] = dp[i-1][j-1]+1$，否则$dp[i][j] = 0$（因为考虑的是<code>str1</code>的第$i$个字符和<code>str2</code>的第$j$个字符结尾，如果不相同直接返回0，有点不好理解）。对于每个位置$i$和$j$，需要维护<code>end</code>和<code>max</code>的值，最后就可以截取得到结果。</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">LCS</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = str1.length();</span><br><span class="line">    <span class="keyword">int</span> n = str2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; ++i) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n; ++j) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>)==str2.charAt(j-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&gt;max) &#123;</span><br><span class="line">                max = dp[i][j];</span><br><span class="line">                end = i-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> str1.substring(end-max+<span class="number">1</span>, end+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;22222&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;34ss222&quot;</span>;</span><br><span class="line">    System.out.println(LCS(str1,str2));</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 222</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两字符串的最长公共子序列"><a href="#两字符串的最长公共子序列" class="headerlink" title="两字符串的最长公共子序列"></a>两字符串的最长公共子序列</h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定两个字符串<code>str1</code>和 <code>str2</code>，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 <code>&quot;-1&quot;</code> 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code>是 <code>&quot;abcde&quot;</code>的子序列，但 <code>&quot;aec&quot;</code>不是 <code>&quot;abcde&quot;</code>的子序列。</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<h5 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h5><p>如果是返回两字符串的最长公共子序列的长度，那么直接用动态规划即可，但是这里需要返回最长公共子序列。我们可以先用动态规划做一些预处理，然后再这$dp$数组的“指引”下，操作字符串。</p>
<p>用动态规划时，明确$dp$数组的含义，这里$dp[i][j]$表示字符串<code>str1</code>前$i$个字符与字符串<code>str2</code>的前$j$个字符的最长公共子序列的长度（最后一个字符的索引分别为$i-1$和$j-1$），则当$str1.charAt(i-1)==str2.charAt(j-1)$时，$dp[i][j] = dp[i-1][j-1]+1$，否则$dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])$。得到$dp$数组后，我们从后往前处理<code>str1</code>和<code>str2</code>，如果$str1.charAt(i-1)== str2.charAt(j-1)$，则将该对应字符加入，$i$和$j$都减一;否则比较$dp[i][j-1]$和$dp[i-1][j]$，$i$和$j$的变化朝着数值大的方向进行。最后别忘了将得到的字符序列反转。</p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">LCS</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> str1Len = str1.length();</span><br><span class="line">    <span class="keyword">int</span> str2Len = str2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str1Len+<span class="number">1</span>][str2Len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=str1Len;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;str2Len;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>) == str2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=str1Len, j=str2Len;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>)== str2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">            s.append(str1.charAt(i-<span class="number">1</span>));</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j-<span class="number">1</span>]&lt;dp[i-<span class="number">1</span>][j]) i--;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;qwesdghgjkjsffg&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;qsjdhgbfrejffjas&quot;</span>;</span><br><span class="line">    System.out.println(LCS(str1,str2));</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// qsdhgjff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍与字符串有关的六个算法题目。</p>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/string-to-integer-atoi">https://leetcode-cn.com/problems/string-to-integer-atoi</a></span></p>
<p><span name="ref2"><a href="https://leetcode-cn.com/problems/compress-string-lcci">https://leetcode-cn.com/problems/compress-string-lcci</a></span></p>
<p><span name="ref3"><a href="https://leetcode-cn.com/problems/add-strings">https://leetcode-cn.com/problems/add-strings</a></span></p>
<p><span name="ref4"><a href="https://leetcode-cn.com/problems/multiply-strings">https://leetcode-cn.com/problems/multiply-strings</a></span></p>
<p><span name="ref5"><a href="https://leetcode-cn.com/problems/longest-common-subsequence">https://leetcode-cn.com/problems/longest-common-subsequence</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>密文策略属性基加密</title>
    <url>/2021/04/09/%E5%AF%86%E6%96%87%E7%AD%96%E7%95%A5%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>千呼万唤，在前面的一些知识的铺垫中，终于引来了我们的主角：属性基加密（ABE）。都知道属性基加密的思想是让密文和密钥与属性集合和访问结构产生关联，当且仅当属性集合满足访问结构的时候，方能解密成功。那么根据这其中两两的对应关系，又可以将属性基加密分为两类，即密钥策略属性基加密<sup><a href="ref1">1</a></sup>（KP-ABE）和密文策略属性基加密<sup><a href="ref2">2</a></sup>（CP-ABE）。<br><span id="more"></span></p>
<ul>
<li><strong>KP-ABE:</strong> 用户的密钥中蕴含访问结构（访问策略），密文中对应着一系列属性集合，当且仅当密文的属性集合满足用户密钥的访问结构时，用户才能解密成功。细想下来，用户是主体，只有特定的密文才能与之匹配，从而解密。</li>
<li><strong>CP-ABE:</strong> 用户的密钥对应着一系列属性的集合，密文中蕴含着访问结构（策略），当且仅当用户的属性集合满足密文的访问结构时，用户才能解密成功。细想下来，密文是主体，只有特定的密钥才能与之匹配，从而解密。</li>
</ul>
<p>二者对比可以发现，CP-ABE中数据拥有者（加密明文得到密文的人）可以根据自己的需求，定义合适的访问结构，让他所期待的一群用户能够解密，这正好适合构建云环境或者雾环境中数据的安全共享方案，描述的是一对多、多对多的数据共享场景。因此下面着重介绍CP-ABE（后面的文章也都是CP-ABE方案）。</p>
<h4 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h4><p><strong>Setup</strong> 挑战者运行Setup算法，将系统的公共参数$PK$给攻击者。</p>
<p><strong>Phase 1</strong>攻击者对一系列的属性集合$S_1,S_2,…,S_{q_1}$进行密钥问询。</p>
<p><strong>Challenge</strong>攻击者提交两个等长的明文$M_0$和$M_1$，此外，攻击者提交一个他希望挑战的访问结构$\mathbb{A}^+$，其中要求Phase 1阶段问询的属性集合$S_1,S_2,…,S_{q_1}$都不满足访问结构$\mathbb{A}^+$。挑战者抛掷一枚硬币$b \in \left \{ 0,1 \right \}$，然后用$\mathbb{A}^+$加密$M_b$。最后，挑战者将密文$CT^+$交给攻击者。</p>
<p><strong>Phase 2 </strong> Phase 1阶段重复，但是问询的属性集合$S_{q_1+1},…,S_q$还是不能满足访问结构$\mathbb{A}^+$。</p>
<p><strong>Guess</strong> 攻击者给出$b$的猜想$b^\prime$。</p>
<p>定义上述交互游戏中攻击者的优势为$Pr\left [ {b}’-b \right ]-\frac{1}{2}$。</p>
<p>上述的攻击者和挑战者的游戏在模糊身份基加密中有所介绍，但是不同的是：模糊身份基加密中是选择身份模型（selective-ID），而属性基加密中是选择集合模型（selective-set）。而且上述模型有两个地方需要注意：</p>
<ul>
<li>以上模型没有Init阶段（在模糊身份基加密的模型中有init阶段），称之为选择明文攻击下不可区分安全（IND-CPA）。如果在Init阶段攻击者声明想要挑战的访问结构，则称之为选择安全模型。很显然，选择安全模型描述的安全性弱一些。</li>
<li>若是在Phase 1阶段还适应性地查询密文，则称之为适应性选择密文攻击安全模型1（CCA1），若是继续在Phase 2阶段还适应性地查询密文，则称之为适应性选择密文攻击安全模型2（CCA2)。很显然，就安全性而言，IND-CPA、CCA1、CCA2依次增强。</li>
</ul>
<h4 id="CP-ABE具体构造"><a href="#CP-ABE具体构造" class="headerlink" title="CP-ABE具体构造"></a>CP-ABE具体构造</h4><h5 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a><strong>Setup</strong></h5><p>系统选择双线性群$\mathbb{G}_0$，阶数为$p$，生成元为$g$。然后随机选择两个指数$\alpha ,\beta \in \mathbb{Z}_p$，系统公开参数为：</p>
<script type="math/tex; mode=display">
PK=\left ( \mathbb{G}_0,g,h=g^\beta ,f=g^{1/\beta },e\left ( g,g \right )^\alpha  \right ).</script><p>主密钥为：$MK=\left ( \beta ,g^\alpha  \right )$。</p>
<h5 id="Encrypt-PK-M-mathcal-T"><a href="#Encrypt-PK-M-mathcal-T" class="headerlink" title="Encrypt($PK,M,\mathcal{T}$)"></a>Encrypt($PK,M,\mathcal{T}$)</h5><p>用访问控制树$\mathcal{T}$对消息$M$进行加密，具体过程如下：</p>
<p>针对树$\mathcal{T}$中的每一个节点$x$（包括联系属性的叶子节点），选择一个与之对应的多项式$q_x$。多项式$q_x$的的最高次数为$d_x=k_x-1$。</p>
<p>多项式的选取遵循由根节点到叶子节点（从上到下）的方式。从根节点$R$开始，选择秘密值$s \in \mathbb{Z}_p$，并设置$q_R \left(0 \right)=s$，然后随机选择其他项的次数。对于其他节点$x$，递归的设置$q_x \left( 0 \right) = q_{p\left(x \right)} \left(index\left(x \right) \right)$，至于$q_x$的其他系数随机选择。</p>
<p>记$Y$为树$\mathcal{T}$的叶子节点的集合，然后密文可以表示为：</p>
<script type="math/tex; mode=display">
CT=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},
C_y^\prime=H \left(att \left(y \right) \right) ^ {q_y \left( 0  \right )} \right).</script><p>其中，$att \left(y \right)$表示的是叶子节点$y$对应的属性，$H \left( \cdot \right)$表示将属性映射到$\mathbb{G}_0$。</p>
<h5 id="KeyGen-MK-S"><a href="#KeyGen-MK-S" class="headerlink" title="KeyGen($MK,S$)"></a>KeyGen($MK,S$)</h5><p>给定一个用户的属性集合$S$，输出对应的密钥$SK$，具体如下：</p>
<p>随机选择$r \in \mathbb{Z}_p$，对于$\forall j \in S$， 随机选择$r_j \in \mathbb{Z}_p$，然后计算密钥如下：</p>
<script type="math/tex; mode=display">
SK=\left( D=g^{\left(\alpha +r \right)/\beta}, \forall j \in S: D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=g^{r_j} \right).</script><h5 id="Delegate-SK-widetilde-S"><a href="#Delegate-SK-widetilde-S" class="headerlink" title="Delegate($SK,\widetilde{S}$)"></a>Delegate($SK,\widetilde{S}$)</h5><p>这个算法的作用是给属性比自己少的用户生成密钥（Delegate字面意思为委派，相当于自己得到密钥后，成了一个“小”的密钥产生中心（KGC）），具体过程如下：</p>
<p>给定另一个属性集合$\widetilde{S}$，满足$\widetilde{S} \subseteq S$。由于已经知道了$S$对应的密钥$SK=(D,\forall j \in S: D_j, D_j^\prime)$，则在此基础上随机选择$\widetilde{r} \in \mathbb{Z}_p$，对于$\forall k \in \widetilde{S}$， 随机选择$\widetilde{r}_k \in \mathbb{Z}_p$，产生$\widetilde{S}$对应的密钥如下：</p>
<script type="math/tex; mode=display">
\widetilde{SK}=(\widetilde{D}=Df^{\widetilde{r}},\forall k \in \widetilde{S}:
\widetilde{D}_k=D_kg^{\widetilde{r}}H(k)^{\widetilde{r}_k},\widetilde{D}_k^\prime=D_k^\prime g^{\widetilde{r}_k}).</script><h5 id="Decrypt-CT-SK"><a href="#Decrypt-CT-SK" class="headerlink" title="Decrypt($CT,SK$)"></a>Decrypt($CT,SK$)</h5><p>密文的形式为：</p>
<script type="math/tex; mode=display">
CT=\left( \mathcal{T}, \widetilde{C}=Me\left ( g,g \right )^{\alpha s},C=h^s,\forall y \in Y:C_y=g^{q_y \left(0 \right )},C_y^\prime=H \left(att \left(y \right) \right) ^ {q_y \left( 0  \right )} \right).</script><p>密钥的形式为：</p>
<script type="math/tex; mode=display">
SK=\left( D=g^{\left(\alpha +r \right)/\beta}, \forall j \in S: D_j=g^r\cdot H(j)^{r_j}, D_j^\prime=g^{r_j} \right).</script><p>首先定义一个递归的函数$DecryptNode(CT,SK,x)$（由下到上）:</p>
<ul>
<li><p>如果$x$为叶子节点，记$i=att(x)$。</p>
<ul>
<li><p>若$i \in S$（用户拥有属性$i$），则</p>
<script type="math/tex; mode=display">
DecryptNode(CT,SK,x) = \frac{e(D_i, C_x)}{e(D_i^\prime , C_x^ \prime)}= \frac{e(g^r \cdot H(x)^{r_i}, h^{q_x(0)})}{e(g^{r_i} , H(i)^{q_x(0)})} = e(g,g)^{rq_x(0)}.</script></li>
<li><p>若$i \notin S$，则定义$DecryptNode(CT,SK,x) =\perp $。</p>
</li>
</ul>
</li>
<li><p>如果$x$为非叶子节点，则$DecryptNode(CT,SK,x)$的计算规则如下：</p>
<ul>
<li><p>对于$x$节点的所有孩子节点$z$，调用$F_z = DecryptNode(CT,SK,z)$函数，记$F_z \neq \perp $的所有节点的集合为$S^ \prime$，若$|S^ \prime|&lt;k_x$，则$DecryptNode(CT,SK,x) =\perp $。</p>
</li>
<li><p>相反的话，则选取$S^ \prime$集合中任意$k_x$个元素组成集合$S_x$，按如下方式计算$DecryptNode(CT,SK,x)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&F_z=\prod _{z \in S_x} F_z ^{\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g) ^ {rq_z(0)}) ^ {\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g) ^ {rq_{p(z)}(index(z))}) ^ {\Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=\prod _{z \in S_x} (e(g,g)  ^ {r \cdot q_x(i) \cdot \Delta _{i,S_x^ \prime} (0)} \nonumber \\
&=e(g,g)^{rq_x(0)}.\nonumber
\end{aligned}</script></li>
</ul>
</li>
</ul>
<p>从递归函数的形式上看，尽管叶子节点和非叶子节点的具体计算方式不一样，但是有着统一的形式，因此只要能够依次满足条件地计算出树中适当个数的节点秘密值，就可以解密根节点的秘密值。即当属性集合$S$满足访问结构$\mathcal{T}$，那么就可以解密得到:</p>
<script type="math/tex; mode=display">
A = DecryptNode(CT,SK,r)=e(g,g)^{rq_R(0)} = e(g,g)^{rs}.</script><p>最后即可解密成功：</p>
<script type="math/tex; mode=display">
\widetilde{C}/(e(C,D)/A) = \widetilde{C}/(e(h^s,g^{((\alpha + r)/\beta )})/e(g,g)^{rs}) = M.</script><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上便是最初的CP-ABE方案的构造，访问结构由访问控制树的形式给出，方案中除了基本的系统初始化、密钥生成、加密和解密四个步骤外，还有一个密钥“委派”的步骤，这个可能是受分层身份基加密（HIBE)的影响。文中抵抗共谋攻击的方式是靠随机数$r$，对于每一个用户都会有一个不同的$r$，从递归函数$DecryptNode$可以看出每一步计算都有$r$项参与，如果没有足够多的项是无法解密根节点的秘密值，进而无法解密密文，而不同的$r$得到的结果不能进行拉格朗日插值，算出结果。以后的ABE方案侧重于用户撤销、属性撤销、多个属性权威等等安全需求，这些在之后的文章中有介绍。</p>
<p><span name="ref1">V. Goyal, O. Pandey, A. Sahai, and B. Waters, “Attribute-Based Encryption for Fine-grained Access Control of Encrypted Data,” in <em>Proceedings of the 13th ACM Conference on Computer and Communications Security</em>, Alexandria, Virginia, USA, 2006, pp. 89–98.</span></p>
<p><span name="ref2">J. Bethencourt, A. Sahai, and B. Waters, “Ciphertext-Policy Attribute-Based Encryption,” in <em>IEEE Symposium on Security &amp; Privacy</em>, Oakland, USA, May 2007, pp. 321–334.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>访问结构</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的二叉树操作</title>
    <url>/2021/04/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文主要结合代码来介绍二叉树的有关操作，包括二叉树的深度、平衡二叉树、前序遍历、中序遍历、后序遍历、层序遍历以及打印每一个根到叶子路径节点集合等操作。</p>
<span id="more"></span>
<ul>
<li><p>二叉树的深度：从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度</p>
</li>
<li><p>平衡二叉树：如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树</p>
</li>
<li><p>前序遍历：先访问根节点，再访问左子树，最后访问右子树。</p>
</li>
<li><p>中序遍历：先访问左子树，再访问根节点，最后访问右子树。</p>
</li>
<li><p>后序遍历：先访问左子树，再访问右子树，最后访问根节点。</p>
</li>
<li><p>层序遍历：根据二叉树的层次（或者深度）从根节点逐层输出节点。</p>
</li>
<li><p>根到叶子路径：从根节点到每个叶子节点的路径节点集合。</p>
</li>
</ul>
<p>下面首先给出本文中全部算法的测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeNode h4 = <span class="keyword">new</span> TreeNode(<span class="number">10</span>);</span><br><span class="line">    TreeNode h5 = <span class="keyword">new</span> TreeNode(<span class="number">30</span>);</span><br><span class="line">    TreeNode h2 = <span class="keyword">new</span> TreeNode(<span class="number">20</span>, h4, h5);</span><br><span class="line">    TreeNode h3 = <span class="keyword">new</span> TreeNode(<span class="number">50</span>);</span><br><span class="line">    TreeNode h1 = <span class="keyword">new</span> TreeNode(<span class="number">40</span>, h2, h3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于遍历有关操作都是将值放入List数组中的，因此为了看的结果方便，编写了<u>工具类matrixOperation</u>，后续的遍历有关的操作都是默认放在<u>traverse类</u>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">matrixOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix2d</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组长度为：&quot;</span>+list.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;list.get(i).size();++j)&#123;</span><br><span class="line">                System.out.print(list.get(i).get(j)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix1d</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组长度为：&quot;</span>+list.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size();++i)&#123;</span><br><span class="line">            System.out.print(list.get(i) +<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的深度和平衡性"><a href="#二叉树的深度和平衡性" class="headerlink" title="二叉树的深度和平衡性"></a>二叉树的深度和平衡性</h4><p>一般通过递归简单地计算出一个二叉树的深度，然后递归的判断二叉树是否平衡：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Balance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Depth(root.left),Depth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanceTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanceTree(root.left) &amp;&amp; isBalanceTree(root.right) &amp;&amp; Math.abs(Depth(root.left) - Depth(root.right)) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeNode h4 = <span class="keyword">new</span> TreeNode(<span class="number">10</span>);</span><br><span class="line">    TreeNode h5 = <span class="keyword">new</span> TreeNode(<span class="number">30</span>);</span><br><span class="line">    TreeNode h2 = <span class="keyword">new</span> TreeNode(<span class="number">20</span>, h4, h5);</span><br><span class="line">    TreeNode h3 = <span class="keyword">new</span> TreeNode(<span class="number">50</span>);</span><br><span class="line">    TreeNode h1 = <span class="keyword">new</span> TreeNode(<span class="number">40</span>, h2, h3);</span><br><span class="line">    System.out.println(Balance.Depth(h1));</span><br><span class="line">    System.out.println(Balance.isBalanceTree(h1));</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h4><p>为了节省空间，这里以中序遍历为主，以递归和迭代的方式进行介绍；因为前序遍历和后序遍历的思路是一样的，所有就只说有变化的地方。</p>
<h5 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inOrder01</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    in(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(TreeNode root, List list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    in(root.left, list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    in(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">matrixOperation.printMatrix1d(traverse.inOrder01(h1));</span><br><span class="line"><span class="comment">//数组长度为：5</span></span><br><span class="line"><span class="comment">//10 20 30 40 50 </span></span><br></pre></td></tr></table></figure>
<p>前序遍历和后序遍历与中序遍历的区别是，在list中添加root.val的时机不同，其添加顺序与对应的访问根节点的顺序一致，即前序遍历先添加根节点值，再递归左右子树；后序遍历先递归左右子树，再添加根节点值。</p>
<h5 id="中序遍历（迭代）"><a href="#中序遍历（迭代）" class="headerlink" title="中序遍历（迭代）"></a>中序遍历（迭代）</h5><p>中序遍历是说先访问左子树，再访问根节点，最后访问右子树，但是我们是从根节点开始，而根节点却是后出的，因此想到了借助栈来迭代实现二叉树的中序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inOrder02</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    TreeNode tmp = root;</span><br><span class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span> || s.size() != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tmp !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(tmp);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = s.pop();</span><br><span class="line">        res.add(tmp.val);</span><br><span class="line">        tmp = tmp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">matrixOperation.printMatrix1d(traverse.inOrder02(h1));</span><br><span class="line"><span class="comment">//数组长度为：5</span></span><br><span class="line"><span class="comment">//10 20 30 40 50</span></span><br></pre></td></tr></table></figure>
<p>对于迭代法的前序遍历，因为首先访问根节点，所以将res.add(tmp.val)操作放在s.push(tmp)之后；对于二叉树的后序遍历，因为其遍历顺序是<u>左右中</u>，而颠倒之后为<u>中右左</u>，恰恰与前序遍历的<u>中左右</u>类似，不同点是右子树的优先级高，优先遍历，所以先遍历中右左顺序，再将得到的序列逆序即为后序遍历序列。</p>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><h5 id="一层输出"><a href="#一层输出" class="headerlink" title="一层输出"></a>一层输出</h5><p>这里一层输出是指输出的序列为一维的list，即不区分每一层。既然是层序遍历，因而是先访问到先输出，所以要借助队列数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">levelT</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span>(q.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">        TreeNode tmp = q.poll();</span><br><span class="line">        res.add(tmp.val);</span><br><span class="line">        <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>) q.add(tmp.left);</span><br><span class="line">        <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>) q.add(tmp.right);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">matrixOperation.printMatrix1d(traverse.levelT01(h1));</span><br><span class="line"><span class="comment">//数组长度为：5</span></span><br><span class="line"><span class="comment">//40 20 50 10 30 </span></span><br></pre></td></tr></table></figure>
<h5 id="两层输出"><a href="#两层输出" class="headerlink" title="两层输出"></a>两层输出</h5><p>这里两层输出是指输出的序列为二维的list，即区分每一层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; levelT02(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span>(q.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> l= q.size();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l; ++i)&#123;</span><br><span class="line">            TreeNode tmp = q.poll();</span><br><span class="line">            path.add(tmp.val);</span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>) q.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>) q.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">matrixOperation.printMatrix2d(traverse.levelT02(h1));</span><br><span class="line"><span class="comment">//数组长度为：3</span></span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//20 50</span></span><br><span class="line"><span class="comment">//10 30</span></span><br></pre></td></tr></table></figure>
<h4 id="根到叶子路径集合"><a href="#根到叶子路径集合" class="headerlink" title="根到叶子路径集合"></a>根到叶子路径集合</h4><p>打印每条路径的集合，结果为二维list。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问根到叶子节点每一条路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; everyPath(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(root, res, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">    tmp.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backtrack(root.left, res, tmp);</span><br><span class="line">    backtrack(root.right, res, tmp);</span><br><span class="line">    tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了回溯算法来求解每一个集合，算法中传递了两个集合，一个是结果list，即res，还有一个是路径集合，即path，需要注意的是：</p>
<ul>
<li>方法体中的用到的tmp需要时当前path的复制，这是因为path是递归传入的，如果直接使用path作为当前方法提的tmp的话，它会动态修改里边的内容，造成在某个特定的方法体中添加的元素错误（不确定），因此传入之后复制其内容，重新记为tmp使用，使得不与传入参数path耦合，使得结果集正确。</li>
<li>注意在结果集res中添加tmp的时机，也就是说只有当遇到了叶子节点，才将该节点加入到tmp中，进而将tmp加入到res中。</li>
</ul>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">matrixOperation.printMatrix2d(traverse.everyPath(h1));</span><br><span class="line"><span class="comment">//数组长度为：3</span></span><br><span class="line"><span class="comment">//40 20 10 </span></span><br><span class="line"><span class="comment">//40 20 30 </span></span><br><span class="line"><span class="comment">//40 50 </span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文针对常见的二叉树结构的一些常见的操作进行介绍，具体包括计算二叉树的深度、判断二叉树是否平衡、递归和迭代前中后序遍历二叉树、层次遍历二叉树、回溯算法打印根到叶子节点集合。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>回溯</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的数据结构</title>
    <url>/2021/04/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>数据结构，百度百科<sup><a href="ref">1</a></sup>上的定义是“带有结构特征的数据元素的集合，研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系”。数据的逻辑结构反映的是数据结构之间的逻辑关系，而数据的物理结构侧重的是数据的逻辑结构在计算机存储空间的存在形式。都说“程序”=“数据结构”+“算法”，由此可见数据结构的重要性。常见的数据结构有数组、链表、队列、栈、哈希表、二叉树等等。</p>
<span id="more"></span>
<h4 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h4><p>数组和链表是将具有相同类型的元素存储到一起的集合，其特点是存储的元素是有序可重复，有序描述的是元素存入的顺序和取出的顺序是一致的，而可重复描述的是数组或者链表里边可以存放多个值相同的元素，不具备唯一性。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组最大的特点是，里边元素的内存地址是连续的，可以通过下标快速定位到某个索引处的元素，因此查询速度快，但是插入删除效率低，因为插入或者删除操作会使得数组里边的受影响元素移位，以满足数组的地址连续的特点。</p>
<p>测试数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明一个数组样例&#123;2,3,6,12,5,8,9,4&#125;</span></span><br><span class="line">        <span class="keyword">int</span>[] example = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">// 访问下标2的元素</span></span><br><span class="line">        System.out.println(example[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// 查看数组元素个数</span></span><br><span class="line">        System.out.println(example.length);</span><br><span class="line">        <span class="comment">// 超过元素个数的下表访问抛出java.lang.ArrayIndexOutOfBoundsException异常</span></span><br><span class="line">        System.out.println(example[example.length]);</span><br><span class="line">        <span class="comment">// 输出为：</span></span><br><span class="line">        <span class="comment">//6</span></span><br><span class="line">        <span class="comment">//8</span></span><br><span class="line">        <span class="comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>链表最大的特点是，里边元素的内存地址是不连续的，元素之间通过指针（引用）的形式建立关联。因此链表的查询速度慢，必须得遍历链表才能访问某个元素，但是由于其元素内存地址的不连续性，使得链表的插入和删除效率高，因为插入删除操作对其他元素没多大影响。</p>
<p>定义链表节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, ListNode next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testLinkedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成测试链表20-&gt;30-&gt;7-&gt;3-&gt;23-&gt;15-&gt;16-&gt;8</span></span><br><span class="line">        ListNode l8 = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">        ListNode l7 = <span class="keyword">new</span> ListNode(<span class="number">16</span>, l8);</span><br><span class="line">        ListNode l6 = <span class="keyword">new</span> ListNode(<span class="number">15</span>, l7);</span><br><span class="line">        ListNode l5 = <span class="keyword">new</span> ListNode(<span class="number">23</span>, l6);</span><br><span class="line">        ListNode l4 = <span class="keyword">new</span> ListNode(<span class="number">3</span>, l5);</span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">7</span>, l4);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">30</span>, l3);</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">20</span>, l2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看值为23的节点位置</span></span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">23</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        ListNode tmp = l1;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span> &amp;&amp; tmp.val != target)&#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表中没有target元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target元素索引为&quot;</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">// target元素索引为5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><p>栈和队列也是最常见的两个数据结构。一般的栈和队列都包含通用的方法，如入栈（入队）、出栈（出队）、查看元素（栈中为查看栈顶元素，队列中为查看队首元素）以及查看元素个数等。</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>栈是一种先进后出的数据结构，这表明先存放的元素会后访问。</p>
<p>测试栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2入栈</span></span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 12入栈</span></span><br><span class="line">        stack.push(<span class="number">12</span>);</span><br><span class="line">        <span class="comment">// 查看栈顶元素</span></span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        <span class="comment">// 13入栈</span></span><br><span class="line">        stack.push(<span class="number">13</span>);</span><br><span class="line">        <span class="comment">// 查看栈大小</span></span><br><span class="line">        System.out.println(stack.size());</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">// 12</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// 13</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列这种数据结构现实中有诸多常见的场景，比如各种排队行为，是一种先进先出的数据结构，正好和栈的行为相反。</p>
<p>测试队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2入队</span></span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 12入队</span></span><br><span class="line">        queue.add(<span class="number">12</span>);</span><br><span class="line">        <span class="comment">// 查看队首元素</span></span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        <span class="comment">// 13入队</span></span><br><span class="line">        queue.add(<span class="number">13</span>);</span><br><span class="line">        <span class="comment">// 查看队大小</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表存储的是键值对，这种数据结构根据键计算其哈希值，进而得到索引，将值存到索引位置。而计算索引的时候有可能出现哈希冲突，常见的解决办法是开放地址法以及链地址法。</p>
<p>测试哈希表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;snail&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;25&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;major&quot;</span>, <span class="string">&quot;CS&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(<span class="string">&quot;degree&quot;</span>))&#123;</span><br><span class="line">            System.out.println(map.get(<span class="string">&quot;degree&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key: degree is not in map&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;degree&quot;</span>, map.getOrDefault(<span class="string">&quot;degree&quot;</span>, <span class="string">&quot;master&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;degree&quot;</span>));</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">// key: degree is not in map</span></span><br><span class="line">        <span class="comment">// master</span></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是一种树形数据结构，除了根节点以外，每个节点都有一个父亲节点；除了孩子节点外，每个节点都有孩子节点。</p>
<p>定义二叉树节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val, TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍常见的数据结构的类型以及特点，辅以代码简单介绍它们的用法，关于这些数据结构的使用以及常见的算法，在后边的文章中陆续介绍。</p>
<p><span name="ref"><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=aladdin">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=aladdin</a></span></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
        <tag>二叉树</tag>
        <tag>数组</tag>
        <tag>链表</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的链表操作</title>
    <url>/2021/04/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文主要结合代码来介绍链表的有关操作，包括寻找链表中间节点、反转链表、合并两个有序链表、寻找链表的第k个节点、两个链表的公共节点以及逆序打印链表。</p>
<span id="more"></span>
<p>为了看结果的方便，编写<u>工具类listOperation</u>，后续的对链表的有关操作都默认放在<u>operate类</u>中。注意：以下如果涉及两个链表的操作，则测试用例变化；如果只涉及一个链表，则默认测试用例为第一个测试用例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">listOperation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(tmp.val+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寻找链表中间节点"><a href="#寻找链表中间节点" class="headerlink" title="寻找链表中间节点"></a>寻找链表中间节点</h4><p>这里用到的方法是快慢指针，即有一个快指针，每次走两步，有个慢指针每次走一步，当快指针走到尽头时，慢指针指向的即是链表的中间节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">middleList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试数据</span></span><br><span class="line">    ListNode l8 = <span class="keyword">new</span> ListNode(<span class="number">10</span>);</span><br><span class="line">    ListNode l7 = <span class="keyword">new</span> ListNode(<span class="number">6</span>, l8);</span><br><span class="line">    ListNode l6 = <span class="keyword">new</span> ListNode(<span class="number">8</span>, l7);</span><br><span class="line">    ListNode l5 = <span class="keyword">new</span> ListNode(<span class="number">7</span>, l6);</span><br><span class="line">    ListNode l4 = <span class="keyword">new</span> ListNode(<span class="number">5</span>, l5);</span><br><span class="line">    ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>, l4);</span><br><span class="line">    ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">9</span>, l3);</span><br><span class="line">    ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">20</span>, l2);</span><br><span class="line">    listOperation.printListNode(l1);</span><br><span class="line">    <span class="comment">// 20-&gt;9-&gt;3-&gt;5-&gt;7-&gt;8-&gt;6-&gt;10-&gt;null</span></span><br><span class="line">    System.out.println(operate.middleList(l1).val);</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    System.out.println(operate.middleList(l2).val);</span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上边的测试可以看出，当链表长度$l$为奇数时，算法返回的中间节点即为第$l/2+1$个节点；当链表长度为偶数时，算法返回的节点是第$l/2$个节点。</p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>反转链表也就是改变链表的链向，比如1-&gt;2-&gt;3-&gt;null反转后变为3-&gt;2-&gt;1-&gt;null。算法的核心是维护两个指针，其中一个指向前一个节点，另一个指向后一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode tmp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listOperation.printListNode(operate.reverseList(l1));</span><br><span class="line"><span class="comment">// 10-&gt;6-&gt;8-&gt;7-&gt;5-&gt;3-&gt;9-&gt;20-&gt;null</span></span><br></pre></td></tr></table></figure>
<h4 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h4><p>这个地方有一个小技巧，就是该开始并不确定两个链表中哪一个链表的头节点作为合并后链表的头节点，因此首先new一个虚拟节点head作为头结点，最后返回head.next即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode L1 = l1;</span><br><span class="line">    ListNode L2 = l2;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    <span class="keyword">while</span>(L1 != <span class="keyword">null</span> &amp;&amp; L2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L1.val &lt; L2.val)&#123;</span><br><span class="line">            pre.next = L1;</span><br><span class="line">            L1 = L1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next= L2;</span><br><span class="line">            L2 = L2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = L1==<span class="keyword">null</span> ? L2:L1;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ListNode l8 = <span class="keyword">new</span> ListNode(<span class="number">10</span>);</span><br><span class="line">    ListNode l7 = <span class="keyword">new</span> ListNode(<span class="number">7</span>, l8);</span><br><span class="line">    ListNode l6 = <span class="keyword">new</span> ListNode(<span class="number">3</span>, l7);</span><br><span class="line"></span><br><span class="line">    ListNode l5 = <span class="keyword">new</span> ListNode(<span class="number">15</span>);</span><br><span class="line">    ListNode l4 = <span class="keyword">new</span> ListNode(<span class="number">9</span>, l5);</span><br><span class="line">    ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">8</span>, l4);</span><br><span class="line">    ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">6</span>, l3);</span><br><span class="line">    ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, l2);</span><br><span class="line"></span><br><span class="line">    listOperation.printListNode(l1);</span><br><span class="line">    <span class="comment">// 1-&gt;6-&gt;8-&gt;9-&gt;15-&gt;null</span></span><br><span class="line">    listOperation.printListNode(l6);</span><br><span class="line">    <span class="comment">// 3-&gt;7-&gt;10-&gt;null</span></span><br><span class="line">    listOperation.printListNode(operate.mergeList(l1, l6));</span><br><span class="line">    <span class="comment">// 1-&gt;3-&gt;6-&gt;7-&gt;8-&gt;9-&gt;10-&gt;15-&gt;null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表倒数第k个节点"><a href="#链表倒数第k个节点" class="headerlink" title="链表倒数第k个节点"></a>链表倒数第k个节点</h4><p>要想找链表的倒数第k个节点，核心思想还是快慢指针，快指针先走k步，然后慢指针开始走，这样，当快指针走到尽头时，慢指针指向的节点即为倒数第k个节点。需要注意的是，得先判断输入的k值是否合法，所以得先遍历链表，然后进行长度比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode tmp = head;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; count)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的k值大于链表长度！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k+<span class="number">1</span>) slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode res = operate.getKthFromEnd(l1,<span class="number">8</span>);</span><br><span class="line">System.out.println(res == <span class="keyword">null</span>?-<span class="number">1</span>: res.val);</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h4 id="两个链表的公共节点"><a href="#两个链表的公共节点" class="headerlink" title="两个链表的公共节点"></a>两个链表的公共节点</h4><p>有两种思路，第一种是两个指针遍历，第二种是借助栈。</p>
<h5 id="双指针遍历"><a href="#双指针遍历" class="headerlink" title="双指针遍历"></a>双指针遍历</h5><p>两个链表l1和l2有着这样的事实：假设有两个指针tmp1和tmp2分别遍历l1和l2，tmp1遍历完l1从l2开始继续遍历l2，而tmp2遍历完l2又从l1开始继续遍历，那么他们最终会交于一点，该节点不为空的话必然是公共节点，如果为空，则表示l1与l2没有公共节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findCommonListNode01</span><span class="params">(ListNode h1, ListNode h2)</span></span>&#123;</span><br><span class="line">    ListNode tmp1 = h1;</span><br><span class="line">    ListNode tmp2 = h2;</span><br><span class="line">    <span class="keyword">if</span>(h1 == <span class="keyword">null</span> || h2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp1 != tmp2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp1 == <span class="keyword">null</span>) tmp1 = h2;</span><br><span class="line">        <span class="keyword">else</span> tmp1 = tmp1.next;</span><br><span class="line">        <span class="keyword">if</span>(tmp2 == <span class="keyword">null</span>) tmp2 = h1;</span><br><span class="line">        <span class="keyword">else</span> tmp2 = tmp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="借助栈"><a href="#借助栈" class="headerlink" title="借助栈"></a>借助栈</h5><p>直观的想法是，既然两个链表有公共节点，这意味着该节点之后的节点一定还是公共的，那么我们可以从尾到头比较两链表，最后一个相同的节点即为第一个公共节点。因为是“倒着比较”，自然用到栈这种结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findCommonListNode02</span><span class="params">(ListNode h1, ListNode h2)</span></span>&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;ListNode&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(h1 == <span class="keyword">null</span> || h2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode tmp1 = h1, tmp2 = h2;</span><br><span class="line">    <span class="keyword">while</span>(tmp1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        s1.push(tmp1);</span><br><span class="line">        tmp1 = tmp1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        s2.push(tmp2);</span><br><span class="line">        tmp2 = tmp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp1 = s1.pop();</span><br><span class="line">    tmp2 = s2.pop();</span><br><span class="line">    <span class="keyword">if</span>(tmp1 != tmp2) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode com = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp1 == tmp2)&#123;</span><br><span class="line">        com = tmp1;</span><br><span class="line">        tmp1 = s1.pop();</span><br><span class="line">        tmp2 = s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode l5 = <span class="keyword">new</span> ListNode(<span class="number">15</span>);</span><br><span class="line">ListNode l4 = <span class="keyword">new</span> ListNode(<span class="number">9</span>, l5);</span><br><span class="line">ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">8</span>, l4);</span><br><span class="line">ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">6</span>, l3);</span><br><span class="line">ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, l2);</span><br><span class="line"></span><br><span class="line">ListNode l8 = <span class="keyword">new</span> ListNode(<span class="number">10</span>, l3);</span><br><span class="line">ListNode l7 = <span class="keyword">new</span> ListNode(<span class="number">7</span>, l8);</span><br><span class="line">ListNode l6 = <span class="keyword">new</span> ListNode(<span class="number">3</span>, l7);</span><br><span class="line"></span><br><span class="line">ListNode h2 = <span class="keyword">new</span> ListNode(<span class="number">15</span>);</span><br><span class="line">ListNode h1 = <span class="keyword">new</span> ListNode(<span class="number">25</span>, h2);</span><br><span class="line"></span><br><span class="line">ListNode res1 = operate.findCommonListNode01(l1, l6);</span><br><span class="line">System.out.println(res1 == <span class="keyword">null</span>? -<span class="number">1</span>:res1.val);</span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line">ListNode res3 = operate.findCommonListNode01(l1, h1);</span><br><span class="line">System.out.println(res3 == <span class="keyword">null</span>? -<span class="number">1</span>:res3.val);</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">ListNode res2 = operate.findCommonListNode02(l1, l6);</span><br><span class="line">System.out.println(res2 == <span class="keyword">null</span>? -<span class="number">1</span>:res2.val);</span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line">ListNode res4 = operate.findCommonListNode02(l1, h1);</span><br><span class="line">System.out.println(res4 == <span class="keyword">null</span>? -<span class="number">1</span>:res4.val);</span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h4 id="逆序打印链表"><a href="#逆序打印链表" class="headerlink" title="逆序打印链表"></a>逆序打印链表</h4><p>有三种思路，第一种通过上面的反转链表打印，第二种借助栈，第三种是递归。</p>
<h5 id="借助反转链表"><a href="#借助反转链表" class="headerlink" title="借助反转链表"></a>借助反转链表</h5><p>这种方式改变了原链表的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listOperation.printListNode(operate.reverseList(l1));</span><br><span class="line"><span class="comment">// 10-&gt;6-&gt;8-&gt;7-&gt;5-&gt;3-&gt;9-&gt;20-&gt;null</span></span><br></pre></td></tr></table></figure>
<h5 id="借助栈-1"><a href="#借助栈-1" class="headerlink" title="借助栈"></a>借助栈</h5><p>典型的后入先出，用栈结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inversePrintList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">        s.push(tmp);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l; ++i)</span><br><span class="line">        System.out.print(s.pop().val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>在打印该节点之前，如果下一个节点不为空，则先打印下一个节点，递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursivePrintList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next != <span class="keyword">null</span>)</span><br><span class="line">            recursivePrintList(head.next);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.val +<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">operate.inversePrintList(l1);</span><br><span class="line"><span class="comment">// 10-&gt;6-&gt;8-&gt;7-&gt;5-&gt;3-&gt;9-&gt;20-&gt;</span></span><br><span class="line">System.out.println();</span><br><span class="line">operate.recursivePrintList(l1);</span><br><span class="line"><span class="comment">// 10-&gt;6-&gt;8-&gt;7-&gt;5-&gt;3-&gt;9-&gt;20-&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要针对链表结构的一些常见的操作进行介绍，具体包括寻找链表中间节点、反转链表、合并两个有序链表、寻找链表的第k个节点、两个链表的公共节点以及逆序打印链表。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>排列和子集问题</title>
    <url>/2021/06/01/%E6%8E%92%E5%88%97%E5%92%8C%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文主要介绍数组的全排列和子集问题，由于数组中的数可能有重复，因此排列和子集问题分别对应数组有重复以及无重复的两种情况。以下是用回溯算法解决这类问题的细节。</p>
<span id="more"></span>
<h4 id="全排列问题11"><a href="#全排列问题11" class="headerlink" title="全排列问题11"></a>全排列问题1<sup><a href="ref1">1</a></sup></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个<strong>不含重复数字的数组</strong> <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。要求按字典序升序输出。</p>
<h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>由于是要输出数组的全排列，因此，每一项必须包含该数组的所有元素，只是每一项的顺序不一样的。如果数组中有<code>n</code>个元素，显然其全排列有<code>n!</code>种，我们可以用回溯法解决该类问题。首先要有一个二维列表res存放结果集，然后需要一个滚动的一维路径path尝试所有的可能。首先确定回溯条件，即当path的容量等于数组<code>nums</code>的长度时，结束回溯；然后再回溯过程中，我们每次尝试一种可能，即在<code>[0,nums.length-1]</code>这个范围内回溯，为了排除掉已经使用的<code>nums</code>中的元素，我们需要用一个<code>visit</code>数组记录<code>nums</code>数组中每个元素在该种排列中是否使用过，如果使用过就跳过，否则继续下一轮回溯，直到满足回溯条件结束。题目要求要按照字典序升序输出，因此要对数组进行升序排序。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermuteUnique</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,res,path,visit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] visit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//visit[i]确保第i个数选取以后，不会再重新选择该数，</span></span><br><span class="line">            <span class="comment">//即确保每个排列中的数有且仅有一次出现</span></span><br><span class="line">            <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                visit[i]=<span class="keyword">true</span>;</span><br><span class="line">                backtrack(nums,res,path,visit);</span><br><span class="line">                visit[i]=<span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=permute(nums);</span><br><span class="line">        <span class="comment">//之前定义的打印二维list工具函数</span></span><br><span class="line">        printMatrix2d(res);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//数组长度为：6</span></span><br><span class="line">		<span class="comment">//2 3 4 </span></span><br><span class="line">		<span class="comment">//2 4 3 </span></span><br><span class="line">		<span class="comment">//3 2 4 </span></span><br><span class="line">		<span class="comment">//3 4 2 </span></span><br><span class="line">		<span class="comment">//4 2 3 </span></span><br><span class="line">		<span class="comment">//4 3 2 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全排列问题22"><a href="#全排列问题22" class="headerlink" title="全排列问题22"></a>全排列问题2<sup><a href="ref2">2</a></sup></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个可包含重复数字的序列 <code>nums</code> ，返回其<strong>所有不重复的全排列</strong>。要求按字典序升序输出。</p>
<h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>该题目和全排列1要求是一样的，只不过条件更苛刻，这里的数组里是有重复元素的，因此在遍历得到结果集的过程中需要对得到的重复全排列进行去重，即在回溯过程中需要剪枝。举个例子，<code>nums=[1,2,2]</code>，我们需要一个<code>visit</code>数组对每一次的排列进行记录，首先<code>visit[i]</code>就跳过是因为在一个排列回溯过程中<code>nums[i]</code>用过就跳过该元素，去掉诸如<code>[1,1,1]</code>这样的结果。然后是<code>i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!visit[i-1]</code>就跳过，这是因为防止出现两个<code>[1,2,2]</code>的情况，如果不加此限制条件，则会出现重复，我们不妨假设<code>num=[1,2a,2b]</code>，按照全排列1的思路回溯，首先得到<code>[1]</code>，再到<code>[1,2a]</code>，最后得到<code>[1,2a,2b]</code>，符合回溯结束条件，加入结果集，此时一条分支搜索完毕，回溯搜索其他分支，返回到状态<code>[1,2a]</code>，此时由于<code>[1,2a]</code>状态再无其他分支，因此继续回溯到状态<code>[1]</code>，再到<code>[1,2b]</code>，最后得到<code>[1,2b,2a]</code>，因此出现了重复。<code>`i&gt;0&amp;&amp;nums[i]==nums[i-1]</code>条件显然是指出现相邻的两个元素重复的情况，那么为什么在<code>!visit[i-1]</code>时也要跳过该次回溯呢？因为<code>!visit[i-1]</code>表示元素<code>i</code>之前的元素的<code>visit</code>值为<code>false</code>，表明结果集中已经包含该元素的一个分支，而如果此次再回溯就会重复，是在一个层次的重复；如果<code>visit[i-1]</code>为<code>true</code>，则说明是由上一个<code>i</code>处的回溯到了下一个的<code>i-1</code>处，为同一分支，同一分支代表一个排列，一个排列内是可以重复的。因此整个代码与全排列问题1大致相同，不同之处即为增加了不好理解的条件过滤。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permute</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,res,path,visit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] visit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!visit[i-1]表示当nums中第i个数和第i-1个数相同，且前一个数没有被visit标记为true时，跳过循环</span></span><br><span class="line">            <span class="comment">//这是因为，标记为true，说明是在一个排列中继续回溯，而一个排列中的数是可以重复的；而标记为false，说明第i-1个数肯定先于</span></span><br><span class="line">            <span class="comment">//第i个数完成一次排列，那么此次第i个数的回溯应该跳过，否则会有重复。前者是同一分支的情况，后者是同一层次的情况。</span></span><br><span class="line">            <span class="keyword">if</span>(visit[i] || i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;!visit[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            backtrack(nums,res,path,visit);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=permute(nums);</span><br><span class="line">        printMatrix2d(res);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//数组长度为：12</span></span><br><span class="line">		<span class="comment">//2 3 3 4 </span></span><br><span class="line">		<span class="comment">//2 3 4 3 </span></span><br><span class="line">		<span class="comment">//2 4 3 3 </span></span><br><span class="line">		<span class="comment">//3 2 3 4 </span></span><br><span class="line">		<span class="comment">//3 2 4 3 </span></span><br><span class="line">		<span class="comment">//3 3 2 4 </span></span><br><span class="line">		<span class="comment">//3 3 4 2 </span></span><br><span class="line">		<span class="comment">//3 4 2 3 </span></span><br><span class="line">		<span class="comment">//3 4 3 2 </span></span><br><span class="line">		<span class="comment">//4 2 3 3 </span></span><br><span class="line">		<span class="comment">//4 3 2 3 </span></span><br><span class="line">		<span class="comment">//4 3 3 2 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子集问题13"><a href="#子集问题13" class="headerlink" title="子集问题13"></a>子集问题1<sup><a href="ref3">3</a></sup></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。要求按字典序升序输出。</p>
<h5 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h5><p>如果数组中有<code>n</code>个元素，显然其子集有<code>2^n</code>种，我们可以用回溯法解决该类问题。与全排列问题不同，组合问题是找出所有的子集，因此我们可以按照子集长度从<code>[0,nums.length-1]</code>范围内依次回溯，每次回溯得到的结果集是长度为<code>i</code>的子集。因此回溯算法中我们需要传递的参数除了存放结果的结果集<code>res</code>、滚动的路径集<code>path</code>、判断元素是否使用的标志数组<code>visit</code>，还需要传入目标子集的大小还有一个起始索引<code>begin</code>。在回溯算法中，同样的，首先确定结束条件，即找到的<code>path</code>容量等于传入的<code>size</code>即退出，然后我们不再是从0开始遍历，而是从传入的<code>begin</code>开始，以后的内部回溯则在<code>begin+1</code>处开始，这样做是为了防止出现一种结果集的重复，比如<code>[2,3]</code>，如果从0处开始依次遍历，则会出现<code>2,3</code>和<code>[3,2]</code>重复的问题，因为从<code>i</code>处开始，可能会在后续的回溯中加入<code>i</code>之前的元素，而设置<code>begin</code>，并使下一次回溯从<code>begin+1</code>处开始可以保障结果集始终是往后单向添加元素。这需要与排列问题区分开来，因为排列问题是区分顺序的，而子集问题是不区分顺序的。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSetUnique</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subset(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">            backtrack(nums,res,path,<span class="number">0</span>,visit,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path, <span class="keyword">int</span> begin,<span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                visit[i]=<span class="keyword">true</span>;</span><br><span class="line">                backtrack(nums,res,path,i+<span class="number">1</span>,visit,size);</span><br><span class="line">                visit[i]=<span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=subset(nums);</span><br><span class="line">        printMatrix2d(res);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//数组长度为：16</span></span><br><span class="line">		<span class="comment">//此处表示空集</span></span><br><span class="line">		<span class="comment">//1 </span></span><br><span class="line">		<span class="comment">//2 </span></span><br><span class="line">		<span class="comment">//3 </span></span><br><span class="line">		<span class="comment">//4 </span></span><br><span class="line">		<span class="comment">//1 2 </span></span><br><span class="line">		<span class="comment">//1 3 </span></span><br><span class="line">		<span class="comment">//1 4 </span></span><br><span class="line">		<span class="comment">//2 3 </span></span><br><span class="line">		<span class="comment">//2 4 </span></span><br><span class="line">		<span class="comment">//3 4 </span></span><br><span class="line">		<span class="comment">//1 2 3 </span></span><br><span class="line">		<span class="comment">//1 2 4 </span></span><br><span class="line">		<span class="comment">//1 3 4 </span></span><br><span class="line">		<span class="comment">//2 3 4 </span></span><br><span class="line">		<span class="comment">//1 2 3 4 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子集问题24"><a href="#子集问题24" class="headerlink" title="子集问题24"></a>子集问题2<sup><a href="ref4">4</a></sup></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集不能包含重复的子集。要求按字典序升序输出。。</p>
<h5 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h5><p>我们直接不设置像前面三种题一样的回溯结束条件，直接将此刻的滚动路径集加入结果集，接下来，我们直接在回溯过程中排除掉那些重复的结果即可。和前面的分析一样，首先要跳过<code>visit[i]</code>的情况，因为之前回溯时已经将该值加入<code>path</code>中，再次加入则会使的<code>nums</code>中的某个元素使用多次。其次，我们仍然需要向全排列问题2一样，跳过<code>i&gt;begin&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!visit[i-1]</code>的回溯，这样做是保证在同一层次重复的元素回溯过程剔除，从而去重；然而不同之处是需要像子集问题1一样，回溯从传入的<code>begin</code>开始，并在之后的回溯中<code>+1</code>操作，这与子集问题1的原因是一样的，使得回溯中加入的元素是单向向后的，去除顺序问题导致的重复。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subset(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,res,<span class="number">0</span>,path,visit);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; res,<span class="keyword">int</span> begin,List&lt;Integer&gt; path,<span class="keyword">boolean</span>[] visit)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i] || i&gt;begin&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;!visit[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            visit[i]=<span class="keyword">true</span>;</span><br><span class="line">            backtrack(nums,res,begin+<span class="number">1</span>,path,visit);</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=subset(nums);</span><br><span class="line">        <span class="comment">//实现自己的排序，使得List结果集按照字典序升序排序</span></span><br><span class="line">        <span class="comment">//以下为lambda表达式型写法</span></span><br><span class="line">        res.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.size() == o2.size()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; o1.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o1.get(i) != o2.get(i))</span><br><span class="line">                        <span class="keyword">return</span> o1.get(i) - o2.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o1.size() - o2.size();</span><br><span class="line">        &#125;);</span><br><span class="line">        printMatrix2d(res);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//数组长度为：6</span></span><br><span class="line">		<span class="comment">//此处为空集</span></span><br><span class="line">		<span class="comment">//1 </span></span><br><span class="line">		<span class="comment">//2 </span></span><br><span class="line">		<span class="comment">//1 2 </span></span><br><span class="line">		<span class="comment">//2 2 </span></span><br><span class="line">		<span class="comment">//1 2 2 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要用回溯算法解决全排列问题和子集问题，每个问题包含重复和非重复两种情况。</p>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></span></p>
<p><span name="ref2"><a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></span></p>
<p><span name="ref3"><a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></span></p>
<p><span name="ref4"><a href="https://leetcode-cn.com/problems/subsets-ii/">https://leetcode-cn.com/problems/subsets-ii/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈ABE里的安全性证明</title>
    <url>/2021/04/17/%E6%B5%85%E8%B0%88ABE%E9%87%8C%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>前面介绍了许多ABE方案，比如说CP-ABE、Hur1-ABE、Hur2-ABE、ABE-2EPSR、O-ABE以及DAC-MACS等等，这些方案有的给出了安全性的证明，而有的却没有明确给出。一般的，ABE方案的构造都是基于某个Diffie-Hellman难题，而在证明方案的安全性的时候则将方案规约到已定的数学难题上。以下结合KP-ABE<sup><a href="ref1">1</a></sup>和ABE-2EPSR<sup><a href="ref2">2</a></sup>中的方案一这两个例子，来介绍ABE方案是如何完成其证明过程的。</p>
<span id="more"></span>
<p>在进入本文的主要的内容之前，首先回顾一些本文需要的预备知识，比如安全模型、难题假设等。</p>
<h4 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h4><p><strong>Setup</strong> 挑战者运行Setup算法，将系统的公共参数$PK$给攻击者。</p>
<p><strong>Phase 1</strong>攻击者对一系列的属性集合$S_1,S_2,…,S_{q_1}$进行密钥问询。</p>
<p><strong>Challenge</strong>攻击者提交两个等长的明文$M_0$和$M_1$，此外，攻击者提交一个他希望挑战的访问结构$\mathbb{A}^+$，其中要求Phase 1阶段问询的属性集合$S_1,S_2,…,S_{q_1}$都不满足访问结构$\mathbb{A}^+$。挑战者抛掷一枚硬币$b \in \left \{ 0,1 \right \}$，然后用$\mathbb{A}^+$加密$M_b$。最后，挑战者将密文$CT^+$交给攻击者。</p>
<p><strong>Phase 2 </strong> Phase 1阶段重复，但是问询的属性集合$S_{q_1+1},…,S_q$还是不能满足访问结构$\mathbb{A}^+$。</p>
<p><strong>Guess</strong> 攻击者给出$b$的猜想$b^\prime$。</p>
<p>定义上述交互游戏中攻击者的优势为$Pr\left [ {b}’-b \right ]-\frac{1}{2}$。<br>以上模型称之为ABE的选择集合模型（selective-set）。而且上述模型有两个地方需要注意：</p>
<ul>
<li>以上模型没有Init阶段，称之为选择明文攻击下不可区分安全（IND-CPA）。如果在Init阶段攻击者声明想要挑战的访问结构，则称之为选择安全模型。很显然，选择安全模型描述的安全性弱一些。</li>
<li>若是在Phase 1阶段还适应性地查询密文，则称之为适应性选择密文攻击安全模型1（CCA1），若是继续在Phase 2阶段还适应性地查询密文，则称之为适应性选择密文攻击安全模型2（CCA2)。很显然，就安全性而言，IND-CPA、CCA1、CCA2依次增强。</li>
</ul>
<p>然后针对以上安全模型给出定义：<br>Definition: <em>A ciphertext-policy attribute-based encryption scheme is secure in the Selective-Set model if all polynomial time adversaries have at most a negligible advantage in the above game.</em></p>
<h4 id="难题假设"><a href="#难题假设" class="headerlink" title="难题假设"></a>难题假设</h4><h5 id="DBDH-Assumption"><a href="#DBDH-Assumption" class="headerlink" title="DBDH Assumption"></a>DBDH Assumption</h5><p>DBDH难题描述为：选择一个乘法循环群 $\mathbb{G}_1$，阶数为$p$（$p$的选择依赖于具体方案的安全参数），令$a,b,c,z \in \mathbb{Z}_p$随机选取，$g$为群$\mathbb{G}_1$的生成元，有两个四元组$(A=g^a,B=g^b,C=g^c,e(g,g)^{abc}$和$(A=g^a,B=g^b,C=g^c,e(g,g)^z$，则没有多项式时间算法的攻击者$\mathcal{B}$能以不可忽略的优势分辨上述元组。攻击者$\mathcal{B}$的优势定义为：</p>
<script type="math/tex; mode=display">
|Pr [ \mathcal{B}(A,B,C,e(g,g)^{abc} )=0 ]-Pr [ \mathcal{B}(A,B,C,e(g,g)^z )=0 ]|</script><h5 id="q-PBDHE-Assumption"><a href="#q-PBDHE-Assumption" class="headerlink" title="q-PBDHE Assumption"></a>q-PBDHE Assumption</h5><p>判定型q-PBDHE假设描述为：选择一个乘法循环群 $\mathbb{G}_1$，阶数为$p$（$p$的选择依赖于具体方案的安全参数），令$a,s, b_1, …, b_q \in \mathbb{Z}_p$随机选取，$g$为群$\mathbb{G}_1$的生成元，如果攻击者获得向量$\overrightarrow{y} =$</p>
<script type="math/tex; mode=display">
\begin{align}
&g,g^s,g^a,...,g^{a^q},,g^{a^{q+2}},...,g^{a^{2q}} \nonumber \\
&\forall_{1\leq j\leq q}  g^{sb_j},g^{a/b_j},...,g^{a^q / b_j},,g^{a^{q+2} / b_j},...,g^{a^{2q} / b_j} \nonumber\\
&\forall_{1<\leq j,k\leq q,k\neq j} g^{a \cdot s \cdot b_k / b_j}, ..., g^{a^q \cdot s \cdot b_k / b_j} \nonumber
\end{align}</script><p>那么他分辨$e(g,g)^{a^{q+1}s} \in \mathbb{G}_2$和$ \mathbb{G}_2$上的一个随机元素$R$是困难的。<br>定义攻击者决定$\mathbb{G}_1$上的q-PBDHE困难问题的优势为：</p>
<script type="math/tex; mode=display">
|Pr[\mathcal{B}(\overrightarrow{y},T=e(g,g)^{a^{q+1}s})=0]-Pr[\mathcal{B}(\overrightarrow{y},T=R)=0]|</script><h4 id="安全性证明的核心思想"><a href="#安全性证明的核心思想" class="headerlink" title="安全性证明的核心思想"></a>安全性证明的核心思想</h4><p>构造方案的时候，我们会基于某个数学难题，然后想到因为方案是困难的，那么我们的方案就是不可攻破的，这其中涉及的证明方法是反证法。<br>那么上述安全模型的交互式游戏又是什么鬼呢？其实证明过程中会涉及四类参与者，分别是算法攻击者、算法挑战者、难题攻击者和难题挑战者。各参与者的工作如下：</p>
<ul>
<li>算法攻击者：即想方设法攻破我们基于某个难题构造的ABE方案</li>
<li>算法挑战者：为算法攻击者提出挑战，即为我们构造的ABE方案生成参数，响应算法攻击者的问询</li>
<li>难题攻击者：即想方设法攻破某个难题</li>
<li>难题挑战者：为难题攻击者提出挑战，生成难题参数</li>
</ul>
<p>实际证明中是怎么运用反证法思想的呢？既然是反证法思想，那么按照前面的直观感觉“因为方案是困难的，那么我们的方案就是不可攻破的”，现在要证明它的逆否命题是正确的，而实际规约证明也的确是这么干的。<br>实际证明首先会假定算法攻击者以某个不可忽略的优势攻破了我们的难题，然后另一边，难题攻击者想法设法要攻破难题，很显然他自己无能为力，但是他并不“笨”，虽然自己解决不了，他可以借助别人的优势，他会怎么做呢？他很狡猾，伪装成算法的挑战者，当难题挑战者扔给他“一大把”参数的时候，他就像“看天书一样”无法参透这其中的答案，然后他合理的包装“这些参数”，达到什么效果呢？达到让算法攻击者以为这是用所构造的方案正常加密的密文的形式。由于假定算法攻击者能以不可忽略的优势攻破我们的方案，那么他就能“显摆地”将答案告诉难题攻击者了，这样一来，难题攻击者根据算法攻击者的反馈，就能以不可忽略的优势解决这个特定的难题。然而这个难题已经证明是困难的了，也就是说不存在这样的多项式时间算法攻击者决定这个特定的难题，由此可见，前面的假设是错误的，即算法攻击者不能以不可忽略的优势攻破我们的方案，由此完成方案的安全性证明。<br>以下结合两个具体的方案来详细说明。</p>
<h4 id="KP-ABE的安全性证明"><a href="#KP-ABE的安全性证明" class="headerlink" title="KP-ABE的安全性证明"></a>KP-ABE的安全性证明</h4><p>首先给出定理：<br>Theorem 1. <em> If an adversary can break our scheme in the Attribute-based Selective-Set model, then a simulator can be constructed to play the Decisional BDH game with a non-negligible advantage.</em><br>证明：假设存在一个多项式时间的攻击者$\mathcal{A}$（算法攻击者）可以在选择集合模型下以优势$\varepsilon $攻破我们的方案，那么我们就可以构造一个仿真者$\mathcal{B}$（难题攻击者）以优势$\varepsilon / 2$决定DBDH难题。<br>首先由难题挑战者生成难题参数。难题挑战者选择两个乘法循环群$\mathbb{G}_1$和$\mathbb{B}_2$，选择一个双线性映射$e$和生成元$g \in \mathbb{G}_1$。然后难题挑战者抛掷一枚硬币$\mu \in \left\{0,1 \right\}$，如果$\mu=0$，则令$Z=e(g,g)^{abc}$，否则令$Z=e(g,g)^z$。最后将参数$(A=g^a,B=g^b,C=g^c,Z)$给难题攻击者，其中$a,b,c,z$都是随机选取。<br>下面就是难题攻击者伪装成算法挑战者与算法攻击者进行交互游戏，我们重点来看Challenge和Guess这两个步骤，其他步骤是根据自己构造的方案用给定的参数模拟的过程。</p>
<p><strong> Challenge. </strong> 攻击者$\mathcal{A}$提交两个等长的明文$m_0$和$m_1$给算法挑战者，挑战者抛掷一枚硬币$b=\left\{0,1\right\}$，然后用参数加密明文$m_b$，具体密文为：</p>
<script type="math/tex; mode=display">
E=(\gamma,E^\prime=m_bZ,\left\{E_i=C^{r_i} \right\}_{i \in \gamma})</script><ul>
<li>如果$\mu=0$ ，也就是$Z=e(g,g)^{abc}$，我们将$s$设置为$c$，则有$Y^s=(e(g,g)^{ab})^c=e(g,g)^{abc}$，$E_i=(g^{r_i})^c=C^{r_i}$，所以这时候的密文是用方案加密$m_b$的合法密文，那么算法攻击者有一定的优势可以区分是$m_0$加密了还是$m_1$加密了。</li>
<li>如果$\mu=1$，即$Z=e(g,g)^z$，此时$E^\prime =m_be(g,g)^z$，因为$z$是随机选取的，与$a,b,c$关系独立，明文$m_b$的信息完全被“淹没”了，换句话说，算法攻击者无法分辨是$m_0$加密了还是$m_1$加密了。</li>
</ul>
<p><strong>Guess. </strong> 算法攻击者最终会输出一个$b$的猜想$b^\prime$。如果$b^\prime=b$，难题挑战者输出$\mu^\prime=0$表示给定的元组是含有关联的四元组，否则输出$\mu^\prime=1$表示给定的元组是随机四元组。</p>
<p>下面分析算法挑战者决定DBDH难题的优势：</p>
<ul>
<li>如果$\mu=1$，算法攻击者没有任何优势分辨$b$，那么只能猜了，即$Pr\left[b=b^\prime |\mu=1 \right] = 1/2$，因为当$b \neq b^\prime$时，输出$\mu ^\prime=1$，因此$Pr\left[\mu ^\prime=\mu |\mu=1 \right] = 1/2$。</li>
<li>如果$\mu=0$，算法攻击者有$\varepsilon$的优势分辨$b$，因此$Pr\left[b=b^\prime |\mu=0 \right] = 1/2+\varepsilon$。因为当$b = b^\prime$时，输出$\mu ^\prime=0$，因此$Pr\left[\mu ^\prime=\mu |\mu=0 \right] = 1/2+\varepsilon$。</li>
</ul>
<p>综上得算法挑战者决定DBDH难题的总优势为:</p>
<script type="math/tex; mode=display">
\begin{aligned}
& Adv_{\mathcal{B}}=1/2 \cdot Pr[\mu ^\prime=\mu |\mu=0] +1/2 \cdot Pr[\mu ^\prime=\mu |\mu=1 ] - 1/2 \nonumber \\
& =1/2 \cdot (1/2+\varepsilon) + 1/2 \cdot 1/2 -1/2 = \varepsilon/2.
\end{aligned}</script><p>而这一结论与DBDH难题假设相违背，因此说明前面的假设是错误的，从而完成安全性证明。</p>
<h4 id="ABE-2EPSR第一种构造证明"><a href="#ABE-2EPSR第一种构造证明" class="headerlink" title="ABE-2EPSR第一种构造证明"></a>ABE-2EPSR第一种构造证明</h4><p>该方案是基于q-PBDHE难题，这个难题给定的参数比较复杂，因此详细说明，证明过程是如何将难题参数嵌入到交互式游戏，从而使得密文和密钥的生成与方案相一致。<br>首先给出定理：<br>Theorem 2. <em> Suppose the decisional q-parallel BDHE assumption holds. Then no polytime adversary can selectively break our system with a challenge matrix of size $l^+ \times n^+$, where $l^+,n^+ \leq q$.</em><br>证明：假设存在一个多项式时间算法攻击者$\mathcal{A}$以不可忽略的优势$Adv_{\mathcal{A}}=\varepsilon$在上述选择安全游戏中（增加了Init阶段的指定）攻破构造的方案，而且假设挑战矩阵$M^+$的维数不超过$q$，那么我们就可以构造一个仿真者$\mathcal{B}$（难题攻击者）决定q-PBDHE难题。</p>
<p><strong> Init.</strong> 仿真者得到q-PBDHE难题参数$\overrightarrow{y},T$。算法攻击者给定想要挑战的访问结构$(M^+, \rho^+)$，其中，$M^+$有$n^+$列。</p>
<p><strong> Setup. </strong> 仿真者选择随机数$\alpha ^\prime \in \mathbb{Z}_p$，暗含着设置$\alpha = \alpha^\prime + a^{a^{q+1}}$，即$e(g,g)^\alpha = e(g^a,g^{a^q}) e(g,g)^{\alpha^\prime}$。为了模拟方案中的$h_1,…,h_U$，针对每一个$x$（其中$1\leq x\leq U$），选择随机值$z_x$，记$X$表示索引$i$的集合，其中$\rho^+(i) \in x$（即属性x对应矩阵行的索引）。仿真者模拟$h_x$如下：</p>
<script type="math/tex; mode=display">
h_x=g^{z_x} \prod_{i \in X} g^{aM_{i,1}^+/b_i} \cdot g^{a^2 M_{i,2}^+/b_i} ... g^{a^{n^+} M_{i,n^+}^+/b_i}.</script><p>如果$X=\varnothing $，那么$h_x=g^{z_x}$。</p>
<p><strong> Phase 1. </strong> 该阶段仿真者响应攻击者的密钥问询。假设仿真者得到的问询是针对属性集合$S$，其中$S$不满足访问结构$M^+$。<br>仿真者首先选择随机数$r \in \mathbb{Z}_p$，然后找一个向量$\overrightarrow{\omega} =(\omega_1,…,\omega_{n^+}) \in \mathbb{Z}_p$，使得$\omega_1=-1$，而对于其他所有$i$（$\rho^+(i) \in S$）有$\overrightarrow{\omega}M_i^+ = 0$。<br>仿真者按如下定义$t$：</p>
<script type="math/tex; mode=display">
t=r+\omega_1a^q + \omega_2a^{q-1} +... +\omega_{n^+}a^{q-n^+ +1}.</script><p>计算$L=g^r \prod_{i=1,…,n+} (g^{a^{q+1-i}})^{\omega_i} = g^t$，计算$K=g^{\alpha^\prime} g^{ar} \prod_{i=2,…,n^+}(g^{a^{q+2-i}})^{\omega_i}$。<br>然后需要计算$\forall x \in S: \left\{K_x \right\}$：</p>
<ul>
<li>如果对于$x \in S$，没有$i$使得$\rho^+(i)=x$，$K_x=L^{z_x}$。</li>
<li>如果对于$x \in S$，有$i$使得$\rho^+(i)=x$，令$X$表示索引$i$的集合，其中$\rho^+(i) \in x$，仿真者按如下方式计算$K_x$:</li>
</ul>
<script type="math/tex; mode=display">
K_x=L^{z_x} \prod_{i \in X} \prod_{j=1,...,n^+} (g^{(a^j/b_i)r} \prod_{k=1,...,n^+,k \neq j} (g^{a^{q+1+j-k}/b_i})^{\omega_k} )^{M_{i,j}^+}</script><p><strong> Challenge. </strong> 攻击者提交两个等长的明文$m_0,m_1$给仿真者，仿真者抛掷一枚硬币$b=\left\{ 0,1 \right\}$，得到密文部件$C=m_bT \cdot e(g^s,g^{\alpha ^\prime})$和$C^\prime = g^s$。<br>仿真者随机选择$y_2^\prime,…,y_{n^+}^\prime$，选择要分享的随机向量：</p>
<script type="math/tex; mode=display">
\overrightarrow{v} = (s, sa+y_2^\prime,sa^2+y_3^\prime,..., sa^{n^+-1}+y_{n^+}^\prime) \in \mathbb{Z}_p^{n^+}</script><p>此外，他还选择$r_1^\prime,…, r_l^\prime$。<br>对于任意$i=1,…,n^+$，定义$R_i$为所有$k \neq i$且$\rho^+(i) = \rho^+(k)$的索引集合，即所有与第$i$行对应的属性相同的其他行的行号，然后与属性有关的密文部件为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& D_i = g^{-r_i^ \prime}g^{-sb_i} \nonumber \\
& C_i=h_{\rho^+(i)}^{r_i^\prime} (\prod_{j=2,...,n^+} (g^a)^{M_{i,j}^+}y_j^\prime) (g^{b_i \cdot s})^{-z_{\rho^+(i)}} \cdot (\prod_{k \in R_i} \prod_{j=1,...,n^+} (g^{a^j \cdot s \cdot (b_i/b_k)})^{M_{k,j}^+})
\end{aligned}</script><p><strong> Phase 2. </strong> Phase 1阶段重复。</p>
<p><strong> Guess. </strong> 攻击者最终输出对$b$的猜想$b^\prime$。如果$b=b^\prime$，则输出$b^\prime=0$表明$T=e(g,g)^{a^{q+1}s}$；否则输出$b^\prime=1$表明$T$是群$\mathbb{G}_T$上的随机值。</p>
<ul>
<li>如果$T=e(g,g)^{a^{q+1}s}$，那么仿真者完好的模拟了$m_b$的加密过程，所以$|Pr[\mathcal{B}(\overrightarrow{y},T=e(g,g)^{a^{q+1}s})=0]=1/2+Adv_{\mathcal{A}}$。</li>
<li>如果$T$是一个随机元素，那么明文$m_b$完全“淹没”在随机值里，攻击者没有优势只能靠猜测，所以$Pr[\mathcal{B}(\overrightarrow{y},T=R)=0]=1/2$。<br>到了这一步就和KP-ABE的结果是一样的，得到的结论是：如果存在多项式时间算法的攻击者可以以不可忽略的优势攻破方案，那么就存在多项式时间算法的攻击者可以以不可忽略的优势决定q-PBDHE难题，而这与q-PBDHE是不可攻破的难题这一事实矛盾，说明前面的假设是错误的，即证明方案是安全的。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上边的两个例子很清晰地用反证法的思想证明出了方案的安全性。仔细对比然后思考，会发现大框架都是一样的，而且在Guess阶段计算优势的套路也是固定的，唯一有变化的是Setup、Phase 1和Challenge部分模拟成方案的参数计算相应的密文密钥的细节不同，而这些恰恰是安全性证明中的难点，即如何很好地将难题中的参数构造到方案中去，这一点在第二个例子里边得到了充分地体现。</p>
<p><span name="ref1">V. Goyal, O. Pandey, A. Sahai, and B. Waters, “Attribute-based encryption for fine-grained access control of encrypted data,”in <em>Proc. 13th ACM. Conf. Computer and communications security</em>, 2006, pp. 89-98.</span></p>
<p><span name="ref2">B. Waters, “Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization,” in <em>Proc. PKC’11</em>, 2011, pp. 53–70, Springer.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>安全性证明</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊身份基加密</title>
    <url>/2021/04/08/%E6%A8%A1%E7%B3%8A%E8%BA%AB%E4%BB%BD%E5%9F%BA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>属性基加密<sup><a href="ref1">1</a></sup> （ABE）的思想来源于模糊身份基加密<sup><a href="ref2">2</a></sup> （FIBE），那么在深入了解属性基加密之前，我们先来认识一下模糊身份基加密。模糊身份基加密的主要思想是：用户用一系列的属性$\omega $表示，密文用一系列的属性${\omega }’$表示，系统设定一个容忍值$d$，当二者属性的相交个数大于$d$，即$|{\omega }’\cap \omega|\geq d$时，方能解密成功。</p>
<span id="more"></span>
<h4 id="双线性映射"><a href="#双线性映射" class="headerlink" title="双线性映射"></a>双线性映射</h4><p>双线性映射是基于Diffie-Hellman难题构建属性基加密算法的数学基础，此处的模糊身份基加密也用到了该数学基础。</p>
<p>令$\mathbb{G}_1,\mathbb{G}_2$为两个阶为$p$的乘法循环群，$g$为$\mathbb{G}_1$的生成元，一个从$\mathbb{G}_1$到$\mathbb{G}_2$的映射$e:\mathbb{G}_1 \times \mathbb{G}_1\rightarrow  \mathbb{G}_2$是双线性的，当其满足以下三点：</p>
<ul>
<li>双线性：$\forall g, h \in \mathbb{G}_1$和$a,b \in \mathbb{Z}_p$有$e\left ( g^a, h^b \right ) = e\left ( g, h \right )^{ab}$；</li>
<li>非退化性：$e\left ( g, h \right ) \neq 1$；</li>
<li>可计算性：$\forall g, h \in \mathbb{G}_1$，存在有效的算法计算$e\left ( g, h \right ) \in \mathbb{G}_2$。</li>
</ul>
<h4 id="FIBE具体构造"><a href="#FIBE具体构造" class="headerlink" title="FIBE具体构造"></a>FIBE具体构造</h4><h5 id="Set-up"><a href="#Set-up" class="headerlink" title="Set up"></a>Set up</h5><p>首先定义系统的属性空间$U$，为了简单起见，将$\mathbb{Z}_p$中前$|U|$个元素作为属性即整数1,…,$|U|$。然后在$\mathbb{Z}_p$中随机均匀选择$t_1,…,t_{|U|}$。最后在$\mathbb{Z}_p$中随机均匀选择$y$。系统的公共参数表示为：</p>
<script type="math/tex; mode=display">
T_1=g^{t_1},...,g^{t_{|U|}},Y=e\left ( g,g \right )^y.</script><p>系统的主密钥为：</p>
<script type="math/tex; mode=display">
t_1,...t_{|U|},y.</script><h5 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key Generation"></a>Key Generation</h5><p>对于某个用户身份$\omega  \in U$（属性集合），选择一个$d-1$阶多项式$q$，使得$q\left ( 0 \right )=y$。私钥部件为$\left ( D_i \right )_{i \in \omega}$，其中$D_i = g^{\frac{q\left ( i \right )}{t_i}}$。</p>
<h5 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h5><p>密文的加密与一系列的属性${\omega}’$有关，将发送的消息映射到$\mathbb{G}_2$上，即$M \in \mathbb{G}_2$。然后随机选择一个$\mathbb{Z}_p$上的秘密值$s$，加密得到的密文形式如下：</p>
<script type="math/tex; mode=display">
E=\left ( {\omega}',{E}'=MY^s,\left \{ E_i =T_i^s\right \}_{i \in {\omega}'} \right ).</script><h5 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h5><p>假设用户的属性集合与蕴含在密文中的属性集合相交的属性个数多于$d$，即$|{\omega }’\cap \omega|\geq d$，那么他能按照如下方式成功解密。首先在属性交集${\omega }’\cap \omega$中任意选择$d$个属性集合$S$，然后根据拉格朗日插值算法，可以解密密文：</p>
<script type="math/tex; mode=display">
\begin {aligned}
&{E}'/\prod _{i \in S}\left ( e\left ( D_i,E_i \right ) \right )^{\Delta_{i,S}\left ( 0 \right )} \nonumber \\
&=Me\left ( g,g \right )^{sy}/ \prod _{i \in S}\left ( e\left ( g^{\frac{q\left ( i \right )}{t_i}},g^{st_i} \right ) \right )^{\Delta_{i,S}\left ( 0 \right )} \nonumber \\
&=Me\left ( g,g \right )^{sy}/ \prod _{i \in S}\left ( e\left ( g,g \right )^{sq\left ( i \right )} \right )^{\Delta_{i,S}\left ( 0 \right )} \nonumber \\
&=M \nonumber
\end {aligned}</script><p>其中$\Delta_{i,S}\left ( 0 \right )$为拉格朗日系数的0值，$\Delta_{i,S}\left ( x \right ) = \prod _{j \in S,j\neq i}\frac{x-j}{i-j}$。</p>
<h4 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h4><p>密码学中构建方案，通常将方案的安全性规约到某个数学困难问题，用反证法的思想，当难题是困难的，那么攻破方案就是困难的。FIBE方案是在选择身份模型下将方案规约到MBDH问题。以下描述模糊选择身份模型（Selective-ID模型，属性基加密中为Selective-Set模型）：</p>
<p><strong>Init</strong> 攻击者声明想要挑战的身份$\alpha $（即一个属性集合）。</p>
<p><strong>Setup</strong> 挑战者运行系统的Setup算法生成系统参数，将公共参数告诉攻击者。</p>
<p><strong>Phase 1</strong> 攻击者可以对许多身份$\gamma _j$进行密钥询问，前提是$\forall j$，$|\gamma _j \cap \alpha |&lt;d$。</p>
<p><strong>Challenge</strong>  攻击者提交两个等长的密文$M_0,M_1$，挑战者抛掷一枚硬币$b \in \left \{ 0,1 \right \}$，然后用$\alpha $加密$M_b$。挑战者将密文发送给攻击者。</p>
<p><strong>Phase 2</strong> Phase 1过程重复。</p>
<p><strong>Guess</strong> 攻击者给出$b$的猜想${b}’$。</p>
<p>以上游戏中攻击者的优势定义为$Pr\left [ {b}’=b \right ]-\frac{1}{2}$。</p>
<p>以后会发现证明安全性的时候，以上攻击者和挑战者的游戏经常看到。在这里就不细讲证明的过程，后面会专门写一篇文章介绍方案的安全性证明。从FIBE的构造来看，主要运用的数学技巧是双线性映射和拉格朗日插值。这两个数学技巧是构建属性基加密方案的基础，FIBE只是用了一次插值，而前面介绍的访问控制树结构本质上是多次运用拉格朗日插值，然后构造成一个访问结构供方案使用，还有一些分层的FIBE（可以理解为分层的门限属性基加密），也是多次运用拉格朗日插值，比如文献<sup><a href="ref3">3</a></sup> 等。</p>
<p><span name="ref1">J. Bethencourt, A. Sahai, and B. Waters, “Ciphertext-Policy Attribute-Based Encryption,” in <em>IEEE Symposium on Security &amp; Privacy</em>, Oakland, USA, May 2007, pp. 321–334.</span></p>
<p><span name="ref2">A. Sahai and B. Waters, “Fuzzy Identity-Based Encryption,” in <em>Proceedings of the 24th annual international conference on Theory and Applications of Cryptographic Techniques</em>, Arahus, Denmark, 2005, pp. 457–473.</span></p>
<p><span name="ref3">M. Chase, “Multi-Authority Attribute Based Encryption,” in <em>Proceedings of 4th Theory of Cryptography Conference on Theory of Cryptography (TCC’07)</em>, 2007, pp. 515-534.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
        <category>身份基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>访问结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索有关示例1</title>
    <url>/2021/04/28/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%9C%89%E5%85%B3%E7%A4%BA%E4%BE%8B1/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>深度优先搜索算法是遍历或者搜索树或者图问题的常用结局思路，其算法的核心思想为：对于每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。本文中就四个例子来说明深度优先搜索算法的解题思路。</p>
<span id="more"></span>
<h4 id="岛屿数量1"><a href="#岛屿数量1" class="headerlink" title="岛屿数量1"></a>岛屿数量<sup><a href="ref1">1</a></sup></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>给定的是一个二值矩阵，需要计算所谓的“岛屿”数量，对此我们可以从上到下、从左到右依次遍历矩阵，当遇到一个为1的点时，计数加一，然后对改点进行深度优先搜索（即上下左右四个方向），将和该点在“一块”的点置0，最后返回计数值，即为岛屿数量。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IslandCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 测试矩阵</span></span><br><span class="line">        <span class="comment">// 0 0 1 0</span></span><br><span class="line">        <span class="comment">// 1 1 0 1</span></span><br><span class="line">        <span class="comment">// 0 1 0 0</span></span><br><span class="line">        <span class="comment">// 0 0 1 1</span></span><br><span class="line">        <span class="keyword">char</span>[][] test = &#123;&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;&#125;;</span><br><span class="line">        IslandCount i = <span class="keyword">new</span> IslandCount();</span><br><span class="line">        System.out.println(i.numsIslands(test));</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="二值图像最大的黑点像素数"><a href="#二值图像最大的黑点像素数" class="headerlink" title="二值图像最大的黑点像素数"></a>二值图像最大的黑点像素数</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个只包含0和1的二值图像，计算出该图像中最大黑点像素个数，一个点即为一个像素。</p>
<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>细想一下发现这个题目的描述场景和“岛屿数量”不同，但是题目的条件却是一样的，只不过这里不再是求黑点的个数，而是求最大黑点的像素数，所以只需要在“岛屿数量”的基础上维护一个全局变量，记录遍历过的黑点的最大值，然后返回即可。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxBlackPointCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_px = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                    <span class="keyword">if</span>(max_px &lt; count)&#123;</span><br><span class="line">                        max_px = count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 测试矩阵</span></span><br><span class="line">        <span class="comment">// 0 0 1 0</span></span><br><span class="line">        <span class="comment">// 1 1 0 1</span></span><br><span class="line">        <span class="comment">// 0 1 0 0</span></span><br><span class="line">        <span class="comment">// 0 0 1 1</span></span><br><span class="line">        <span class="keyword">char</span>[][] test = &#123;&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;&#125;;</span><br><span class="line">        MaxBlackPointCount m = <span class="keyword">new</span> MaxBlackPointCount();</span><br><span class="line">        System.out.println(m.numsIslands(test));</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h4><p>在进行深度优先搜索的时候往往需要判定所搜索的点$(i,j)$是否在矩阵范围内，以及对点$(i,j)$的上下左右进行搜索，对于这些操作可以进行适当地“封装”。</p>
<p>判断是否在矩阵内：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] test, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&gt;=<span class="number">0</span> &amp;&amp; i&lt;test.length &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;test[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在点$(i,j)$的上下左右搜索，建立方位矩阵：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] Directions = &#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="被围绕的区域2"><a href="#被围绕的区域2" class="headerlink" title="被围绕的区域2"></a>被围绕的区域<sup><a href="ref2">2</a></sup></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// X X X X      X X X X</span></span><br><span class="line"><span class="comment">// X O O X ---&gt; X X X X</span></span><br><span class="line"><span class="comment">// X O X X ---&gt; X X X X</span></span><br><span class="line"><span class="comment">// O X O O      O X O O</span></span><br></pre></td></tr></table></figure>
<h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><p>这个题要将’X’围绕的’O’换成’X’，仔细一看会发现与外围的’O’有关的’O’是不会改变的，除此之外，所有的’O’都要改变为’X’，因此可以对外围的’O’进行深度优先搜索，将其”附近”的’O’先暂时转化为其他字符，如’#’或者其他，然后遍历矩阵，将’O’变为’X’，将’#’变为’O’即可。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurroundedArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] Directions = &#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m=board.length;</span><br><span class="line">        <span class="keyword">int</span> n=board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = i==m-<span class="number">1</span> || i==<span class="number">0</span> || j==<span class="number">0</span> || j== n-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    dfs(board,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(board,i,j) || board[i][j]==<span class="string">&#x27;X&#x27;</span> || board[i][j]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] direction : Directions)&#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = i+direction[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_j = j+direction[<span class="number">1</span>];</span><br><span class="line">            dfs(board,new_i,new_j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> &amp;&amp; i&lt;board.length &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 测试矩阵</span></span><br><span class="line">        <span class="comment">// X X X X      X X X X</span></span><br><span class="line">        <span class="comment">// X O O X ---&gt; X X X X</span></span><br><span class="line">        <span class="comment">// X O X X ---&gt; X X X X</span></span><br><span class="line">        <span class="comment">// O X O O      O X O O</span></span><br><span class="line">        <span class="keyword">char</span>[][] test = &#123;&#123;<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>&#125;,&#123;<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;X&#x27;</span>&#125;,&#123;<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>&#125;,&#123;<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;O&#x27;</span>&#125;&#125;;</span><br><span class="line">        SurroundedArea s = <span class="keyword">new</span> SurroundedArea();</span><br><span class="line">        s.solve(test);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;test[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                System.out.print(test[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">// X X X X</span></span><br><span class="line">        <span class="comment">// X X X X</span></span><br><span class="line">        <span class="comment">// X X X X</span></span><br><span class="line">        <span class="comment">// O X O O       </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="单词搜索3"><a href="#单词搜索3" class="headerlink" title="单词搜索3"></a>单词搜索<sup><a href="ref3">3</a></sup></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<h5 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h5><p>首先，我们对于矩阵的每一个位置$(i,j)$进行深度优先搜索，记当前搜索的深度为index，如果当前dfs中位置对应的字符与要搜索的字符串s的第index个字符匹配，则将该位置设置为’#’，进入下一个字符（在返回后再将’#’换回该字符，这样是防止已经匹配了的字符重复利用）；如果已经匹配到了s的最后一个字符，则返回true；如果在某个index处不匹配就返回false。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] Directions = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] test, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = test.length;</span><br><span class="line">        <span class="keyword">int</span> width = test[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;width;++j)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = dfs(test, i,j,s,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] test, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String s, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.length()-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> test[i][j] == s.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(test[i][j] == s.charAt(index))&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = test[i][j];</span><br><span class="line">            test[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] direction : Directions)&#123;</span><br><span class="line">                <span class="keyword">int</span> newX = i+direction[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = j+direction[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>((newX&gt;=<span class="number">0</span> &amp;&amp; newX&lt;test.length) &amp;&amp; (newY&gt;=<span class="number">0</span> &amp;&amp; newY&lt;test[<span class="number">0</span>].length) &amp;&amp; test[newX][newY]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                	<span class="keyword">boolean</span> flag = dfs(test,newX,newY,s,index+<span class="number">1</span>);</span><br><span class="line">                	<span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                test[i][j]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        <span class="comment">// A B C E</span></span><br><span class="line">        <span class="comment">// S F C S</span></span><br><span class="line">        <span class="comment">// A D E E</span></span><br><span class="line">        <span class="keyword">char</span>[][] test = &#123;&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;,&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;S&#x27;</span>&#125;,&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;&#125;;</span><br><span class="line">        String s = <span class="string">&quot;ABCCED&quot;</span>;</span><br><span class="line">        Wordsearch w = <span class="keyword">new</span> WordSearch();</span><br><span class="line">        System.out.println(w.solve(test,s));</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文就四个例子对深度优先搜索算法进行介绍，由这些例子可以体会到深度优先算法在遍历搜索时候的思想。</p>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></span><br><span name="ref2"><a href="https://leetcode-cn.com/problems/surrounded-regions">https://leetcode-cn.com/problems/surrounded-regions</a></span><br><span name="ref3"><a href="https://leetcode-cn.com/problems/word-search">https://leetcode-cn.com/problems/word-search</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索有关示例2</title>
    <url>/2021/07/07/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%9C%89%E5%85%B3%E7%A4%BA%E4%BE%8B2/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文继续介绍与深度优先搜素有关的问题，具体包括算术表达式求值、逆波兰式求值、迷宫问题、<code>24​</code>点游戏、括号生成以及二叉树节点路径和。</p>
<span id="more"></span>
<h4 id="算术表达式求值"><a href="#算术表达式求值" class="headerlink" title="算术表达式求值"></a>算术表达式求值</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串描述的算术表达式，计算出结果值。</p>
<p>输入字符串长度不超过<code>100</code>，合法的字符包括”<code>+</code>, <code>-</code>,<code>*</code>,<code>/</code>, <code>(​</code>, <code>)</code>”，”<code>0-9​</code>”，本题目只涉及整型计算。</p>
<p>输入描述：<br>输入算术表达式</p>
<p>输出描述：<br>计算出结果值</p>
<p>示例1<br>输入：<code>400+5</code><br>输出：<code>405</code></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            LinkedList&lt;Character&gt; list = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;c.length; i++)&#123;</span><br><span class="line">                list.add(c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(helper(list));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(LinkedList&lt;Character&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//对于每一个表达式，从左到右遍历</span></span><br><span class="line">        <span class="comment">//栈的作用是保存所有只包含加减关系的数据，包括中间结果</span></span><br><span class="line">        <span class="comment">//中间结果比如有两个数的乘积、商，括号表达式</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//维护一个num变量，用于计算每一个连续数值的值，比如将123+4中的字符串123转换为数值123</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//维护栈中保存数据的符号</span></span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="comment">//维护一个变量pre，用于保存当前操作的前一个操作数</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//取出list中第一个字符</span></span><br><span class="line">            <span class="keyword">char</span> tmp = list.pop();</span><br><span class="line">            <span class="comment">//针对该字符的可能作出不同处理</span></span><br><span class="line">            <span class="comment">//遇到左括号，则括号里仍为一个算术表达式，递归</span></span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                num = helper(list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符为1-9，计算字符串的值</span></span><br><span class="line">            <span class="keyword">if</span>(tmp &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tmp &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                num = <span class="number">10</span> * num + (tmp - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符为操作符</span></span><br><span class="line">            <span class="keyword">if</span>((tmp &lt; <span class="string">&#x27;0&#x27;</span> || tmp &gt; <span class="string">&#x27;9&#x27;</span> || list.size() == <span class="number">0</span>) &amp;&amp; tmp != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                    stack.push(-num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    pre = stack.pop();</span><br><span class="line">                    stack.push(pre * num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                    pre = stack.pop();</span><br><span class="line">                    stack.push(pre / num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录当前的操作符</span></span><br><span class="line">                sign = tmp;</span><br><span class="line">                <span class="comment">//当前字符为操作符，则存储该操作符之前的操作数num清零，以便计算下一个操作数</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到右括号，该层表达式结束</span></span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上述处理，栈中只有相加关系的数据，数据入栈的时候带入了符号</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            res += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逆波兰式求值"><a href="#逆波兰式求值" class="headerlink" title="逆波兰式求值"></a>逆波兰式求值</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>计算逆波兰式（后缀表达式）的值<br>运算符仅包含”<code>+</code>“,”<code>-</code>“,”<code>*</code>“和”<code>/</code>“，被操作数可能是整数或其他表达式<br>例如：<br> <code>[&quot;20&quot;, &quot;10&quot;, &quot;+&quot;, &quot;30&quot;, &quot;*&quot;] -&gt; ((20 + 10) * 30) -&gt; 900</code><br><code>[&quot;40&quot;, &quot;130&quot;, &quot;50&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (40 + (130 / 50)) -&gt; 42</code><br>示例1<br>输入：<code>[&quot;20&quot;,&quot;10&quot;,&quot;+&quot;,&quot;30&quot;,&quot;*&quot;]</code><br>返回值：<code>900</code></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span> <span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(tokens == <span class="keyword">null</span> || tokens.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//从左到右依次遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            String cur = tokens[i];</span><br><span class="line">            <span class="comment">//当前为操作符</span></span><br><span class="line">            <span class="keyword">if</span>(cur.equals(<span class="string">&quot;+&quot;</span>) || cur.equals(<span class="string">&quot;-&quot;</span>) || cur.equals(<span class="string">&quot;*&quot;</span>) || cur.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果操作数不合法,没有足够的数来操作，返回0</span></span><br><span class="line">                <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//取出第二个操作数</span></span><br><span class="line">                <span class="keyword">int</span> after = s.pop();</span><br><span class="line">                <span class="comment">//取出第一个操作数</span></span><br><span class="line">                <span class="keyword">int</span> before = s.pop();</span><br><span class="line">                <span class="comment">//按照+-*/计算得到中间结果并压入栈</span></span><br><span class="line">                <span class="keyword">if</span>(cur.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    s.push(before + after);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    s.push(before - after);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    s.push(before * after);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    s.push(before / after);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//不是操作数，将数压入栈</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = Integer.parseInt(cur);<span class="comment">// 非法字符返回0</span></span><br><span class="line">                    s.push(num);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.size() == <span class="number">1</span> ? s.pop() : <span class="number">0</span>;<span class="comment">//结果要合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>定义一个二维数组<code>N*M​</code>（其中​<code>2&lt;=N&lt;=10​</code>；​<code>2&lt;=M&lt;=10</code>），如​<code>5 × 5​</code>数组下所示：</p>
<script type="math/tex; mode=display">
int maze[5][5] = \begin{bmatrix}
 0 & 1 & 0 & 0 & 0\\ 
0 & 1 & 1 & 1 & 0\\ 
0 & 0 & 0 & 0 & 0\\ 
0 & 1 & 1 & 1 & 0\\ 
0 & 0 & 0 & 1 & 0
\end{bmatrix}</script><p>它表示一个迷宫，其中的<code>1</code>表示墙壁，<code>0</code>表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。入口点为<code>[0,0]</code>,既第一格是可以走的路。<br>输入描述：<br>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的<code>1</code>表示墙壁，<code>0</code>表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。<br>输出描述：<br>左上角到右下角的最短路径，格式如样例所示。</p>
<p>它表示一个迷宫，其中的<code>1​</code>表示墙壁，<code>0​</code>表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。入口点为<code>[0,0]</code>,既第一格是可以走的路。<br>输入描述：<br>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的<code>1</code>表示墙壁，<code>0</code>表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。<br>输出描述：<br>左上角到右下角的最短路径，格式如样例所示。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义点类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString()方法以便输出路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="keyword">this</span>.x + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="comment">//记录迷宫行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="comment">//记录迷宫列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="comment">//记录点的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Point&gt; tempPath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录所有路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Point&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">            rows = sc.nextInt();</span><br><span class="line">            cols = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                    map[i][j] = sc.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始回溯</span></span><br><span class="line">            mazeTrack(map, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//回溯结束后，list里便存放了所有可能的路径</span></span><br><span class="line">            <span class="comment">//对list里的路径按照长度从小到大排序</span></span><br><span class="line">            Collections.sort(list, <span class="keyword">new</span> Comparator&lt;List&lt;Point&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(List&lt;Point&gt; o1, List&lt;Point&gt; o2)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.size()-o2.size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            <span class="keyword">for</span>(Point point:list.get(<span class="number">0</span>))&#123;</span><br><span class="line">                System.out.println(point);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mazeTrack</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//上来就将当前点加入tempPath</span></span><br><span class="line">        Point p = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">        tempPath.add(p);</span><br><span class="line">        <span class="comment">//设置map[x][y] = 1表示当前点已使用</span></span><br><span class="line">        map[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//条件判断，符合条件加入list</span></span><br><span class="line">        <span class="keyword">if</span> (x == rows - <span class="number">1</span> &amp;&amp; y == cols - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//            for (Point point : tempPath)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(point);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;Point&gt;(tempPath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上下左右搜索</span></span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; map[x -<span class="number">1</span>][y] == <span class="number">0</span>) &#123; <span class="comment">//上</span></span><br><span class="line">            mazeTrack(map,x - <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt; rows &amp;&amp; map[x + <span class="number">1</span>][y] == <span class="number">0</span>) &#123; <span class="comment">//下</span></span><br><span class="line">            mazeTrack(map,x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; map[x][y - <span class="number">1</span>] == <span class="number">0</span>)&#123; <span class="comment">//左</span></span><br><span class="line">            mazeTrack(map, x , y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt; cols &amp;&amp; map[x][y + <span class="number">1</span>] == <span class="number">0</span>)&#123; <span class="comment">//右</span></span><br><span class="line">            mazeTrack(map, x , y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原现场</span></span><br><span class="line">        map[x][y] = <span class="number">0</span>;</span><br><span class="line">        tempPath.remove(tempPath.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24点游戏"><a href="#24点游戏" class="headerlink" title="24点游戏"></a>24点游戏</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>问题描述：给出<code>4</code>个<code>1-10</code>的数字，通过加减乘除，得到数字为<code>24</code>就算胜利<br>输入：<br><code>4</code>个<code>1-10</code>的数字。[数字允许重复，但每个数字仅允许使用一次，测试用例保证无异常数字。<br>输出：</p>
<p><code>true or false</code></p>
<p>输入描述：<br>输入<code>4</code>个int整数</p>
<p>输出描述：<br>返回能否得到<code>24</code>点，能输出<code>true</code>，不能输出<code>false</code></p>
<p>示例1<br>输入：<code>7 2 1 10</code><br>输出：<code>true</code></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner input=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">double</span> result=<span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">int</span>[] num=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">		<span class="keyword">while</span>(input.hasNext())&#123;</span><br><span class="line">			<span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">				num[i]=input.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(check(num,temp,result));</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span>[] temp,<span class="keyword">double</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从左到右遍历</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="comment">//temp数组记录num数组中对于位置的数是否用过</span></span><br><span class="line">            <span class="comment">//没有用过则进入条件判断</span></span><br><span class="line">			<span class="keyword">if</span>(temp[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//改变标志为使用</span></span><br><span class="line">				temp[i]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(check(num,temp,result+num[i])</span><br><span class="line">						|| check(num,temp,result-num[i])</span><br><span class="line">						|| check(num,temp,result*num[i])</span><br><span class="line">						|| check(num,temp,result/num[i]))&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">//改变标志为未使用</span></span><br><span class="line">				temp[i]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(result==<span class="number">24</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给出<code>n</code>对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。<br>例如，给出<code>n=3</code>，解集为：<code>&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()()()&quot;, &quot;()(())&quot;</code><br>示例1<br>输入：<code>1</code><br>返回值：<code>[&quot;()&quot;]</code><br>示例2<br>输入：<code>2</code><br>返回值：<code>[&quot;(())&quot;,&quot;()()&quot;]</code></p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parenthesis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">generateParenthesis</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 路径变量，存储每一次深度搜索的值</span></span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//存储结果集</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//开始dfs</span></span><br><span class="line">        dfs(res,path,n,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ArrayList&lt;String&gt; res, StringBuilder path, <span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口，在此步骤添加符合条件的路径</span></span><br><span class="line">        <span class="keyword">if</span>(l==n &amp;&amp; r==n)&#123;</span><br><span class="line">            <span class="comment">//res.add(new String(path));</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剔除不合条件的情况</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;l || r&gt;n || l&gt;n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//第一种情况，进入下一层dfs,path中加入了&quot;(&quot;</span></span><br><span class="line">        dfs(res,path.append(<span class="string">&quot;(&quot;</span>),n,l+<span class="number">1</span>,r);</span><br><span class="line">        <span class="comment">//还原</span></span><br><span class="line">        path.deleteCharAt(path.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第二种情况，进入下一层dfs,path中加入了&quot;(&quot;</span></span><br><span class="line">        dfs(res,path.append(<span class="string">&quot;)&quot;</span>),n,l,r+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//还原</span></span><br><span class="line">        path.deleteCharAt(path.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parenthesis parenthesis = <span class="keyword">new</span> Parenthesis();</span><br><span class="line">        System.out.println(parenthesis.generateParenthesis(<span class="number">3</span>).toString());;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树节点路径和"><a href="#二叉树节点路径和" class="headerlink" title="二叉树节点路径和"></a>二叉树节点路径和</h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个仅包含数字<code>0−9</code> 的二叉树，每一条从根节点到叶子节点的路径都可以用一个数字表示。<br>例如根节点到叶子节点的一条路径是<code>1→2→3</code>,那么这条路径就用<code>123</code> 来代替。<br>找出根节点到叶子节点的所有路径表示的数字之和<br>例如：</p>
<p>这颗二叉树一共有两条路径，<br>根节点到叶子节点的路径<code>1→2</code> 用数字 <code>12</code> 代替<br>根节点到叶子节点的路径<code>1→3</code>用数字 <code>13</code>代替<br>所以答案为<code>12+13=25</code><br>示例1<br>输入：<code>&#123;1,0&#125;</code><br>返回值：<code>10</code><br>示例2<br>输入：<code>&#123;1,#,9&#125;</code><br>返回值：<code>19</code></p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储路径节点</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//前序遍历递归</span></span><br><span class="line">        preorder(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode node, StringBuilder current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入当前节点</span></span><br><span class="line">        current.append(node.val);</span><br><span class="line">        <span class="comment">//一条路径到头，将字符串所表示的数值加入sum</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += Integer.parseInt(current.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        preorder(node.left, current);</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        preorder(node.right, current);</span><br><span class="line">        <span class="comment">//还原</span></span><br><span class="line">        current.deleteCharAt(current.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍与深度优先搜素有关的问题。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>深度优先搜索</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2021/11/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文介绍滑动窗口有关问题，包括滑动窗口的最大值、无重复字符串的最长子串、串联所有单词的子串、字符串的排列、最小覆盖子串以及最长连续1的个数。</p>
<span id="more"></span>
<h4 id="滑动窗口的最大值1"><a href="#滑动窗口的最大值1" class="headerlink" title="滑动窗口的最大值1"></a>滑动窗口的最大值<sup><a href="ref1">1</a></sup></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code>个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p><strong>示例输入</strong>：<code>nums = [1,3,-1,-3,5,3,6,7], k = 3</code></p>
<p><strong>示例输出</strong>：<code>[3,3,5,5,6,7]</code></p>
<p><strong>解释 </strong>:</p>
<p>滑动窗口的位置                最大值</p>
<hr>
<p><code>[1 3 -1] -3 5 3 6 7</code>       3<br> <code>1 [3 -1 -3] 5 3 6 7</code>      3<br> <code>1 3 [-1 -3 5] 3 6 7</code>      5<br> <code>1 3 -1 [-3 5 3] 6 7</code>      5<br> <code>1 3 -1 -3 [5 3 6] 7</code>      6<br> <code>1 3 -1 -3 5 [3 6 7]</code>      7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] pair1, <span class="keyword">int</span>[] pair2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pair1[<span class="number">0</span>] != pair2[<span class="number">0</span>] ? pair2[<span class="number">0</span>] - pair1[<span class="number">0</span>] : pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = pq.peek()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="keyword">while</span> (pq.peek()[<span class="number">1</span>] &lt;= i - k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = pq.peek()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无重复字符串的最长子串2"><a href="#无重复字符串的最长子串2" class="headerlink" title="无重复字符串的最长子串2"></a>无重复字符串的最长子串<sup><a href="ref2">2</a></sup></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例输入</strong>：<code>s = &quot;abcabcbb&quot;</code></p>
<p><strong>示例输出</strong>：<code>3</code></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> l = s.length(), max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>; end&lt;l; end++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(m.containsKey(c))&#123;</span><br><span class="line">                start = Math.max(m.get(c), start);</span><br><span class="line">            &#125;</span><br><span class="line">            m.put(c, end+<span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, end-start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="串联所有单词的子串3"><a href="#串联所有单词的子串3" class="headerlink" title="串联所有单词的子串3"></a>串联所有单词的子串<sup><a href="ref3">3</a></sup></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串<code>s</code>和一些 长度相同 的单词 <code>words</code> 。找出<code>s</code>中恰好可以由<code>words</code> 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 <code>words</code> 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑<code>words</code>中单词串联的顺序。</p>
<p><strong>示例输入</strong>：<code>s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</code></p>
<p><strong>示例输出</strong>：<code>[0，9]</code></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> word_count=words.length;</span><br><span class="line">        <span class="keyword">if</span>(word_count==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> word_len=words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> windows_len=word_count*word_len;</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word_count;i++)&#123;</span><br><span class="line">            map.put(words[i],map.getOrDefault(words[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.length()-windows_len;i++)&#123;</span><br><span class="line">            Map&lt;String,Integer&gt; tmp=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(num&lt;word_count)&#123;</span><br><span class="line">                String str=s.substring(i+num*word_len,i+(num+<span class="number">1</span>)*word_len);</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(str))&#123;</span><br><span class="line">                    tmp.put(str,tmp.getOrDefault(str,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(tmp.get(str)&gt;map.get(str))&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num==word_count) res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的排列4"><a href="#字符串的排列4" class="headerlink" title="字符串的排列4"></a>字符串的排列<sup><a href="ref4">4</a></sup></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你两个字符串 <code>s1</code>和 <code>s2</code>，写一个函数来判断 <code>s2</code>是否包含<code>s1</code>的排列。如果是，返回 <code>true</code> ；否则，返回<code>false</code>。</p>
<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 子串 。</p>
<p><strong>示例输入</strong>：<code>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</code></p>
<p><strong>示例输出</strong>：<code>true</code></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; source=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; cnt=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length()&gt;s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">            source.put(s1.charAt(i),source.getOrDefault(s1.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            cnt.put(s2.charAt(i),cnt.getOrDefault(s2.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s1.length();i&lt;s2.length();i++)&#123;</span><br><span class="line">            Character c1=s2.charAt(i-s1.length());</span><br><span class="line">            <span class="keyword">if</span>(cnt.containsKey(c1))&#123;</span><br><span class="line">                Integer tmp=cnt.get(c1);</span><br><span class="line">                <span class="keyword">if</span>(tmp-<span class="number">1</span>==<span class="number">0</span>) cnt.remove(c1);</span><br><span class="line">                <span class="keyword">else</span> cnt.put(c1,tmp-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.put(s2.charAt(i),cnt.getOrDefault(s2.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(check()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; iterator=source.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Character,Integer&gt; m=iterator.next();</span><br><span class="line">            Character c=m.getKey();</span><br><span class="line">            Integer i=m.getValue();</span><br><span class="line">            <span class="keyword">if</span>(cnt.getOrDefault((c),<span class="number">0</span>)&lt;i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小覆盖子串5"><a href="#最小覆盖子串5" class="headerlink" title="最小覆盖子串5"></a>最小覆盖子串<sup><a href="ref5">5</a></sup></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例输入</strong>：<code>s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</code></p>
<p><strong>示例输出</strong>：<code>&quot;BANC&quot;</code></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; source=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; cnt=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1=s.length();</span><br><span class="line">        <span class="keyword">int</span> l2=t.length();</span><br><span class="line">        <span class="keyword">if</span>(l1&lt;l2) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l2;i++)&#123;</span><br><span class="line">            source.put(t.charAt(i),source.getOrDefault(t.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;l1)&#123;</span><br><span class="line">            Character c=s.charAt(r);</span><br><span class="line">            cnt.put(c,cnt.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(check())&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(min&gt;=r-l+<span class="number">1</span>)&#123;</span><br><span class="line">                    end=r;</span><br><span class="line">                    start=l;</span><br><span class="line">                    min=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Character tmp1=s.charAt(l);</span><br><span class="line">                <span class="keyword">if</span>(cnt.containsKey(tmp1))&#123;</span><br><span class="line">                    Integer tmp2=cnt.get(tmp1);</span><br><span class="line">                    <span class="keyword">if</span>(tmp2==<span class="number">1</span>) cnt.remove(tmp1);</span><br><span class="line">                    <span class="keyword">else</span> cnt.put(tmp1,tmp2-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==Integer.MAX_VALUE?<span class="string">&quot;&quot;</span>:s.substring(start,start+min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; iterator=source.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Character,Integer&gt; m=iterator.next();</span><br><span class="line">            Character c=m.getKey();</span><br><span class="line">            Integer i=m.getValue();</span><br><span class="line">            <span class="keyword">if</span>(cnt.getOrDefault(c,<span class="number">0</span>)&lt;i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长连续1的个数6"><a href="#最长连续1的个数6" class="headerlink" title="最长连续1的个数6"></a>最长连续1的个数<sup><a href="ref6">6</a></sup></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 <code>0</code> 变成<code>1</code>。</p>
<p>返回仅包含<code>1</code>的最长（连续）子数组的长度。</p>
<p><strong>示例输入</strong>：<code>A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</code></p>
<p><strong>示例输出</strong>：<code>6</code></p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, lsum = <span class="number">0</span>, rsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            rsum += <span class="number">1</span> - nums[right];</span><br><span class="line">            <span class="keyword">while</span> (lsum &lt; rsum - k) &#123;</span><br><span class="line">                lsum += <span class="number">1</span> - nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></span></p>
<p><span name="ref2"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></span></p>
<p><span name="ref3"><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/</a></span></p>
<p><span name="ref4"><a href="https://leetcode-cn.com/problems/permutation-in-string/">https://leetcode-cn.com/problems/permutation-in-string/</a></span></p>
<p><span name="ref5"><a href="https://leetcode-cn.com/problems/minimum-window-substring/">https://leetcode-cn.com/problems/minimum-window-substring/</a></span></p>
<p><span name="ref6"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">https://leetcode-cn.com/problems/max-consecutive-ones-iii/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/05/17/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，<strong>通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。</strong></p>
<span id="more"></span>
<p>本文介绍如何使用动态规划解决背包问题，具体包括：0-1背包、完全背包以及多重背包问题。</p>
<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>有 $N$ 种物品和一个容量是$ V$ 的背包，<strong><em>每种物品都只有一件可用</em></strong>。第$ i$ 种物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
<h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>由以上问题描述建立数学模型即，在满足$\sum_{i=1}^N x_i v_i \leq V$（$x_i \in \{0,1\}$表示选择或者不选择物品$i$）的约束下，求解$max \sum_{i=1}^N x_i v_i$。</p>
<p>利用动态规划的分析方法，首先定义$dp[i][j]$数组，表示当背包容量为$j$时，考虑前$i$件物品的最大价值。对于第$i$件物品，有两种可能性，</p>
<ul>
<li>包的剩余容量比$v_i$小，自然装不下，此时$dp[i][j]=dp[i-1][j]$；</li>
<li>当包的剩余容量大于等于$v_i$时，对于第$i$件物品，仍然有两种选择，选择该物品，则$dp[i][j]=dp[i-1][j-v[i]]+w[i]$，不选择该物品，则$dp[i][j]=dp[i-1][j]$。</li>
</ul>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solveBy2D</span><span class="params">(<span class="keyword">int</span> V, <span class="keyword">int</span> N, <span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N ==<span class="number">0</span> || V==<span class="number">0</span> || v == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N +<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i-<span class="number">1</span>][j - w[i - <span class="number">1</span>]] + v[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; N; ++i)&#123;</span><br><span class="line">        w[i] = sc.nextInt();</span><br><span class="line">        v[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res1 =solveBy2D(V, N, w, v);</span><br><span class="line">    System.out.println(<span class="string">&quot;Max value: &quot;</span>+ res1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// N=4 V=5</span></span><br><span class="line"><span class="comment">// v_1=1 w_1=2</span></span><br><span class="line"><span class="comment">// v_2=2 w_2=4</span></span><br><span class="line"><span class="comment">// v_3=3 w_3=4</span></span><br><span class="line"><span class="comment">// v_4=4 w_4=5</span></span><br><span class="line"><span class="comment">// Max value: 8</span></span><br></pre></td></tr></table></figure>
<p>进一步通过手动填表来理解上述的示例。初始化$dp$为$dp[5][6]$，对于$dp[i][0]$和$dp[0][j]$，应该初始化为0，目标是要求$dp[4][5]$。</p>
<p>计算$dp[1][1]$，因为此时背包的容积为1，等于第一件物品的体积1,因此满足可能性二，故$dp[1][1]=max\{dp[0][1],dp[0][1-v[1]]+w[1]\}=2$;对于其他的$i$和$j$，一样的从上到下（$i=1,2,3,4$）从左到右（$j=1,2,3,4,5$）计算，并得到下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">j=0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i=0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
</div>
<p>从计算过程以及递推公式可知，$dp[i][j]$的状态只与$dp[i-1][j]$有关，因此可以通过滚动数组的方法将二维的$dp[i][j]$优化为一维的$dp[j]$，其递推关系为$dp[j]=max\{dp[j],dp[j-v[i]]+w[i]\}$。<strong>需要注意的是，第二层循环需要从大到小循环，因为若是继续从小到大循环，后面算的时候，用的是这一层已经算过的数据，就变成$dp[i][j]=max\{dp[i][j],dp[i][j-v[i]]+w[i]\}$</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solveBy1D</span><span class="params">(<span class="keyword">int</span> V, <span class="keyword">int</span> N, <span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=w[i-<span class="number">1</span>]; --j)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j-w[i-<span class="number">1</span>]]+v[i-<span class="number">1</span>], dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>有 $N$ 种物品和一个容量是$ V$ 的背包，<strong><em>每种物品都有无限件可用</em></strong>。第$ i$ 种物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
<h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>由以上问题描述建立数学模型即，在满足$\sum_{i=1}^N x_i v_i \leq V$（$x_i$表示选择物品$i$的件数）的约束下，求解$max \sum_{i=1}^N x_i v_i$。</p>
<p>利用动态规划的分析方法，首先定义$dp[i][j]$数组，表示当背包容量为$j$时，考虑前$i$件物品的最大价值。对于第$i$件物品，有两种可能性，</p>
<ul>
<li>包的剩余容量比$v_i$小，自然装不下，此时$dp[i][j]=dp[i-1][j]$；</li>
<li>当包的剩余容量大于等于$v_i$时，对于第$i$件物品，仍然有两种选择，选择该物品，则$dp[i][j]=dp[i][j-v[i]]+w[i]$（这个地方与0-1背包不同的地方在于当前背包容量充足的前提下，考虑装入第$i$件物品后，还可以再次考虑该物品，因此状态不再是转移到$dp[i-1]$上，而是$dp[i]$上）；不选择该物品，则$dp[i][j]=dp[i-1][j]$。</li>
</ul>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solveBy2D</span><span class="params">(<span class="keyword">int</span> V, <span class="keyword">int</span> N, <span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N ==<span class="number">0</span> || V==<span class="number">0</span> || v == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N +<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - w[i - <span class="number">1</span>]] + v[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; N; ++i)&#123;</span><br><span class="line">        w[i] = sc.nextInt();</span><br><span class="line">        v[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res1 =solveBy2D(V, N, w, v);</span><br><span class="line">    System.out.println(<span class="string">&quot;Max value: &quot;</span>+ res1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// N=4 V=5</span></span><br><span class="line"><span class="comment">// v_1=1 w_1=2</span></span><br><span class="line"><span class="comment">// v_2=2 w_2=4</span></span><br><span class="line"><span class="comment">// v_3=3 w_3=4</span></span><br><span class="line"><span class="comment">// v_4=4 w_4=5</span></span><br><span class="line"><span class="comment">// Max value: 10</span></span><br></pre></td></tr></table></figure>
<p>进一步通过手动填表来理解上述的示例。初始化$dp$为$dp[5][6]$，对于$dp[i][0]$和$dp[0][j]$，应该初始化为0，目标是要求$dp[4][5]$。</p>
<p>计算$dp[1][1]$，因为此时背包的容积为1，等于第一件物品的体积1,因此满足可能性二，故$dp[1][1]=max\{dp[1][1],dp[0][1-v[1]]+w[1]\}=2$，$dp[1][2]=max\{dp[1][2],dp[1][2-v[1]]+w[1]\}=4$；对于其他的$i$和$j$，一样的从上到下（$i=1,2,3,4$）从左到右（$j=1,2,3,4,5$）计算，并得到下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">j=0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i=0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
</div>
<p>从计算过程以及递推公式可知，$dp[i][j]$的状态只与$dp[i-1][j]$有关，因此可以通过滚动数组的方法将二维的$dp[i][j]$优化为一维的$dp[j]$，其递推关系为$dp[j]=max\{dp[j],dp[j-v[i]]+w[i]\}$，第二次从小到大循环。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solveBy1D</span><span class="params">(<span class="keyword">int</span> V, <span class="keyword">int</span> N, <span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i - <span class="number">1</span>]; j &lt;= V; ++j) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j - w[i - <span class="number">1</span>]] + v[i - <span class="number">1</span>], dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>有 $N$ 种物品和一个容量是 $V$ 的背包。<strong><em>第 $i$ 种物品最多有 $s_i$ 件</em></strong>，每件体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p>
<h5 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h5><p>由以上问题描述建立数学模型即，在满足$\sum_{i=1}^N x_i v_i \leq V$（$x_i\in \{1,2,…,s_i\}$表示选择物品$i$的件数）的约束下，求解$max \sum_{i=1}^N x_i v_i$。</p>
<p>利用动态规划的分析方法，首先定义$dp[i][j]$数组，表示当背包容量为$j$时，考虑前$i$件物品的最大价值。对于第$i$件物品，有两种可能性，</p>
<ul>
<li>包的剩余容量比$v_i$小，自然装不下，此时$dp[i][j]=dp[i-1][j]$；</li>
<li>当包的剩余容量大于等于$v_i$时，对于第$i$件物品，仍然有两种选择，选择$k$个该物品，则$dp[i][j]=dp[i-1][j-k\cdot v[i]]+k \cdot w[i]$；不选择该物品，则$dp[i][j]=dp[i-1][j]$。</li>
</ul>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solveBy1D</span><span class="params">(<span class="keyword">int</span> V, <span class="keyword">int</span> N, <span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v,<span class="keyword">int</span>[] s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=w[i-<span class="number">1</span>]; --j)&#123;</span><br><span class="line">            <span class="comment">//增加一层循环，比较选择k的时候的最大dp</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s[i-<span class="number">1</span>] &amp;&amp; j&gt;=k*w[i-<span class="number">1</span>];k++)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-k*w[i-<span class="number">1</span>]]+k*v[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; N; ++i)&#123;</span><br><span class="line">        w[i] = sc.nextInt();</span><br><span class="line">        v[i] = sc.nextInt();</span><br><span class="line">        s[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res1 =solveBy1D(V, N, w, v, s);</span><br><span class="line">    System.out.println(<span class="string">&quot;Max value: &quot;</span>+ res1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// N=4 V=5</span></span><br><span class="line"><span class="comment">// v_1=1 w_1=2 s_1=3</span></span><br><span class="line"><span class="comment">// v_2=2 w_2=4 s_2=1</span></span><br><span class="line"><span class="comment">// v_3=3 w_3=4 s_3=3</span></span><br><span class="line"><span class="comment">// v_4=4 w_4=5 s_4=2</span></span><br><span class="line"><span class="comment">// Max value: 10</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文通过0-1背包、完全背包以及多重背包的例子，通过问题分析和代码一览动态规划算法是如何解决问题的。动态规划算法通过存储中间结果用空间复杂度换时间复杂度，通过分析问题的状态转移方程有时可以优化算法。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>设计栈和队列</title>
    <url>/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>栈和队列是非常常用的数据结构，本文介绍如何实现自己的栈和队列，以及如果用栈实现队列、用队列实现栈、设计获取最小值的栈。</p>
<span id="more"></span>
<h4 id="实现自己的栈"><a href="#实现自己的栈" class="headerlink" title="实现自己的栈"></a>实现自己的栈</h4><p>用list模拟栈，每次执行push操作则直接将元素加入list；每次执行pop，首先检查list里是否有元素，如果没有，直接返回-1，否则执行pop操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mySt_list</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = list.size();</span><br><span class="line">        <span class="keyword">int</span> tmp = list.get(l-<span class="number">1</span>);</span><br><span class="line">        list.remove(l-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        list.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    mySt_list s = <span class="keyword">new</span> mySt_list();</span><br><span class="line">    s.push(<span class="number">20</span>);</span><br><span class="line">    s.push(<span class="number">15</span>);</span><br><span class="line">    System.out.println(s.pop());</span><br><span class="line">    <span class="comment">// 15</span></span><br><span class="line">    System.out.println(s.size());</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    System.out.println(s.pop());</span><br><span class="line">    <span class="comment">// 20</span></span><br><span class="line">    System.out.println(s.pop());</span><br><span class="line">    <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现自己的队列"><a href="#实现自己的队列" class="headerlink" title="实现自己的队列"></a>实现自己的队列</h4><p>用list模拟队列，每次执行add操作则直接将元素加入list；每次执行poll，首先检查list里是否有元素，如果没有，直接返回-1，否则执行poll操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myQu_list</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        list.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = list.get(<span class="number">0</span>);</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    myQu_list q = <span class="keyword">new</span> myQu_list();</span><br><span class="line">    q.add(<span class="number">20</span>);</span><br><span class="line">    q.add(<span class="number">15</span>);</span><br><span class="line">    System.out.println(q.poll());</span><br><span class="line">    <span class="comment">// 20</span></span><br><span class="line">    System.out.println(q.size());</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    System.out.println(q.poll());</span><br><span class="line">    <span class="comment">// 15</span></span><br><span class="line">    System.out.println(q.poll());</span><br><span class="line">    <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h4><p>用两个自定义的栈s1和s2模拟队列，当所有的add操作都是在s1上push；执行poll操作时，首先检查s2有没有元素，如果没有，就将s1的所有元素push到s2，再检查s2有没有元素，如果还是没有，则队列为空，反之则对s2进行pop操作，即为队列的poll结果；执行size操作时，返回s1和s2的size之和即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myQueue</span> </span>&#123;</span><br><span class="line">    mySt_list s1 = <span class="keyword">new</span> mySt_list();</span><br><span class="line">    mySt_list s2 = <span class="keyword">new</span> mySt_list();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = s2.pop();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        s1.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size()+s2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    myQueue q = <span class="keyword">new</span> myQueue();</span><br><span class="line">    q.add(<span class="number">20</span>);</span><br><span class="line">    q.add(<span class="number">15</span>);</span><br><span class="line">    System.out.println(q.poll());</span><br><span class="line">    <span class="comment">// 20</span></span><br><span class="line">    System.out.println(q.size());</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    System.out.println(q.poll());</span><br><span class="line">    <span class="comment">// 15</span></span><br><span class="line">    System.out.println(q.poll());</span><br><span class="line">    <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><p>用两个自定义的队列q1和q2实现栈，其中q1存储的元素是按当前栈弹出顺序存放，每次在栈中push元素，就在q2上添加该元素，随后将q1中的元素“合并”到q2中，此时q1为空，再交换q1和q2的内容。也就是q1中出队的顺序永远是栈里元素弹栈的顺序，q2永远为空，q2的作用是作为交换的“容器”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myStack</span> </span>&#123;</span><br><span class="line">    myQu_list q1 = <span class="keyword">new</span> myQu_list();</span><br><span class="line">    myQu_list q2 = <span class="keyword">new</span> myQu_list();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        q2.add(val);</span><br><span class="line">        <span class="keyword">while</span> (q1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            q2.add(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        myQu_list tmp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    myStack s = <span class="keyword">new</span> myStack();</span><br><span class="line">    s.push(<span class="number">20</span>);</span><br><span class="line">    s.push(<span class="number">15</span>);</span><br><span class="line">    System.out.println(s.pop());</span><br><span class="line">    System.out.println(s.size());</span><br><span class="line">    System.out.println(s.pop());</span><br><span class="line">    System.out.println(s.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一个队列也可以完成模拟栈的任务，执行push操作时，记录下当前队列大小$l$，然后将压栈元素加入队列，最后将队列中前$l$个元素添加到队列末尾即可。</p>
<h4 id="设计最小栈"><a href="#设计最小栈" class="headerlink" title="设计最小栈"></a>设计最小栈</h4><p>用两个自定义的栈s和min实现，其中s是提供基础的栈操作的，而min压入的是当前层次的最小值。在执行push操作时，首先判断s中是否有元素，如果没有，相应地min也要push；然后判断当前压入s的元素是否比min栈顶元素小，如果是，则也将该元素push进min。在执行pop操作时，首先得判断s中是否有元素，在有元素的前提下，如果s中当前元素即为min当前元素，说明弹出的元素为最小值，故min也对应弹出。执行getMin操作只需要查看min中栈顶元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    mySt_list s = <span class="keyword">new</span> mySt_list();</span><br><span class="line">    mySt_list min = <span class="keyword">new</span> mySt_list();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        s.push(val);</span><br><span class="line">        <span class="keyword">if</span>(min.size() == <span class="number">0</span> || min.peek() &gt;= val)&#123;</span><br><span class="line">            min.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() != <span class="number">0</span> &amp;&amp; s.peek() == min.peek()) min.pop();</span><br><span class="line">        <span class="keyword">return</span> s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MinStack s = <span class="keyword">new</span> MinStack();</span><br><span class="line">    s.push(<span class="number">2</span>);</span><br><span class="line">    s.push(<span class="number">5</span>);</span><br><span class="line">    s.push(<span class="number">1</span>);</span><br><span class="line">    System.out.println(s.getMin());</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    s.pop();</span><br><span class="line">    System.out.println(s.getMin());</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    s.pop();</span><br><span class="line">    System.out.println(s.getMin());</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    s.pop();</span><br><span class="line">    System.out.println(s.getMin());</span><br><span class="line">    <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要是借用list集合实现自己的栈和队列，并用这些为基础，模拟如何用栈实现队列、用队列实现栈以及设计能返回当前最小值的栈。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>访问结构</title>
    <url>/2021/04/07/%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>属性基加密算法（Attribute Based Encryption）是一种特殊的身份及加密算法，身份及加密算法将任何能唯一代表用户身份的信息作为公钥，这样一来大大降低了公钥管理的难度，而属性基加密将用户的身份表示为一系列的属性的集合，当且仅当属性集合满足访问结构时，才能解密成功。<br><span id="more"></span></p>
<p>2005年，A. Sahai和 B. Waters两位大佬提出模糊身份基加密<sup><a href="ref1">1</a></sup> （FIBE）的概念，并在论文的后面引入属性基加密；2006年，J. Bethencourt、 A. Sahai  和 B. Waters这三位大佬首次构建属性基加密方案<sup><a href="ref2">2</a></sup>（确切的来说是密钥策略属性基加密方案，KP-ABE），并在论文后面引入密文策略属性基加密方案；2007年，V. Goyal、 O. Pandey、 A. Sahai 和 B. Waters这四位大佬首次构建密文策略属性基加密方案<sup><a href="ref3">3</a></sup>，从此属性加秘密的研究拉开序幕。</p>
<p>属性集合好理解，也就是将用户用一系列的属性标签表示，那么访问结构到底是什么呢？在描述访问结构之前，首先介绍一下离散对数难题（Discrete Logarithm Problem）、拉格朗日插值算法和单调访问结构（Monotone Access Structure），然后引出属性基加密方案中常用的三种访问结构：与门访问结构（And-Gate），访问控制树（Access Tree）和线性秘密共享（LSSS）。</p>
<h4 id="离散对数难题4"><a href="#离散对数难题4" class="headerlink" title="离散对数难题4"></a>离散对数难题<sup><a href="ref4">4</a></sup></h4><p>令$\alpha \in \mathbb{Z}_{p}$，$G$为一个乘法循环群，群的阶数为$p$，群的一个生成元为$g$，离散对数难题说的是：给定$g,g^a \in G$，对于任何多项式时间的攻击者，其计算出指数$a$的概率是可忽略的，即由$g,g^a \in G$计算出$a$是困难的。</p>
<h4 id="拉格朗日插值算法"><a href="#拉格朗日插值算法" class="headerlink" title="拉格朗日插值算法"></a>拉格朗日插值算法</h4><p>任意给定$k$阶多项式函数，已知给定$k+1$个取值点（互不重复）：$\left ( x_0,y_0 \right ),\left ( x_1,y_1 \right ),…,\left ( x_k,y_k \right )$，其中$i \neq  j$时$x_i \neq  x_j$。可以通过以下插值方式恢复多项式：</p>
<script type="math/tex; mode=display">
L\left ( x \right )=\sum _{j=0}^{k}y_jl_j\left ( x \right )</script><p>其中$l_j\left ( x \right )$为拉格朗日系数：</p>
<script type="math/tex; mode=display">
l_j\left ( x \right )=\prod _{i=0,i\neq j}^k \frac{x-x_i}{x_j-x_i}= \frac{x-x_0}{x_j-x_0}...\frac{x-x_{j-1}}{x_j-x_{j-1}}\cdot \frac{x-x_{j+1}}{x_j-x_{j+1}}...\frac{x-x_k}{x_j-x_k}</script><p>任意多于$k+1$个取值点都能复原多项式。</p>
<h4 id="单调访问结构5"><a href="#单调访问结构5" class="headerlink" title="单调访问结构5"></a>单调访问结构<sup><a href="ref5">5</a></sup></h4><p>令$\left \{ P_1,P_2,…,P_n \right \}$为一系列参与者的集合（属性基加密里边指的是属性），一个集合$ \mathbb{A} \subseteq 2^ { \left  \{ P_1,P_2,…,P_n \right \}} $是单调的，当其满足：$\forall B,C$，如果$B\in \mathbb{A}$且$B\subseteq C$，则$C\in \mathbb{A}$。一个访问结构（单调访问结构）是$\left \{ P_1,P_2,…,P_n \right \}$的幂集的非空子集，即$ \mathbb{A} \subseteq 2^ { \left  \{ P_1,P_2,…,P_n \right \} \setminus \left  \{\varnothing \right \}} $，在$\mathbb{A}$中的集合为授权集合，不在$\mathbb{A}$的集合为非授权集合。</p>
<h4 id="与门访问结构6"><a href="#与门访问结构6" class="headerlink" title="与门访问结构6"></a>与门访问结构<sup><a href="ref6">6</a></sup></h4><p>给定一个属性域$U=\left \{ 1,2,…,n \right \}$，对于该属性域中的每一个属性$\underline{i}\in U$，有三个值可供选择：</p>
<p>$\underline{i}=+i$表示该属性有，$\underline{i}=-i$表示该属性没有，而$\underline{i}=dont care$表示该属性可有可无。访问结构可以表示为与门访问结构$W=\wedge _{i\in I}\underline{i}$，其中$I\subseteq U$表示设置的与访问结构有关的属性集合，因此对于$\underline{i}\in U \setminus I$，其属性都为$\underline{i}=dont care$。</p>
<h4 id="访问控制树2"><a href="#访问控制树2" class="headerlink" title="访问控制树2"></a>访问控制树<sup><a href="ref2">2</a></sup></h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>让$\mathcal{T}$表示一个访问控制树。树的非叶子节点$x$表示一个门限，记$k_x$为节点$x$的门限值，$num_x$为节点$x$的孩子节点总数，那么自然有$0&lt;k_x&lt;num_x$。当$k_x=1$时，即表示或门，当$k_x=num_x$时，即表示与门。树的叶子节点$x$与一个属性相联系，自然地，此时$k_x=1$。</p>
<p>为了表示的方便，定义一些描述节点的函数。记$p\left ( x \right )$表示节点$x$的父亲节点，$index\left ( x \right )$表示在父亲节点看来该节点的索引值（像完全二叉树一样自左向右编号）。如果$x$是一个叶子节点，$attr\left ( x \right )$表示该节点关联的属性值。</p>
<h5 id="满足一个访问控制树"><a href="#满足一个访问控制树" class="headerlink" title="满足一个访问控制树"></a>满足一个访问控制树</h5><p>让$\mathcal{T}$表示一个访问控制树，根节点为$r$。记$\mathcal{T}_x$为根节点为$x$的$\mathcal{T}$（$\mathcal{T}$就可以表示为$\mathcal{T}_r$）的子树。如果属性集合$\gamma$满足访问控制树$\mathcal{T}_x$，则$\mathcal{T}_x\left ( \gamma \right )=1$。$\mathcal{T}_x\left ( \gamma \right )$按如下的方式递归计算：如果$x$为非叶子节点，则计算$x$节点的所有孩子节点${x}’$的$\mathcal{T}_{x}’\left ( \gamma \right )$的值，$\mathcal{T}_x\left ( \gamma \right )=1$当且仅当至少$k_x$个$\mathcal{T}_{x}’\left ( \gamma \right )$返回1。如果$x$为叶子节点，则$\mathcal{T}_x\left ( \gamma \right )=1$当且仅当$attr\left ( x \right ) \in \gamma$。</p>
<h5 id="访问控制树的定义"><a href="#访问控制树的定义" class="headerlink" title="访问控制树的定义"></a>访问控制树的定义</h5><p>对于每一个树中的节点$x$，选择与之对应的多项式$q_x$，多项式的选择遵循自上而下的方式（从根节点到叶子节点），具体如下：</p>
<ul>
<li>对于树中的节点$x$，将多项式$q_x$的最高次数设置为$d_x=k_x-1$，也即该节点门限值减一；</li>
<li>对于根节点$r$，设置$q_r\left ( 0 \right )=y$ ，至于$q_r$的其他系数随机选择；</li>
<li>对于树中的节点$x$，设置$q_x\left ( 0 \right )=q_{p\left(x\right)}\left ( index\left(x\right) \right )$ ，至于$q_x$的其他系数随机选择；</li>
<li>构造属性基加密算法的时候，将叶子节点$z$的值$q_z\left ( 0 \right )$作为属性密钥的有关部件，这样通过拉格朗日插值算法就可以恢复出秘密值（与$y$有关的值）。</li>
</ul>
<h4 id="线性秘密共享5"><a href="#线性秘密共享5" class="headerlink" title="线性秘密共享5"></a>线性秘密共享<sup><a href="ref5">5</a></sup></h4><p>令$\mathbb{P}=\left \{ P_1,P_2,…,P_n \right \}$为一系列参与者的集合，$\mathbb{P}$上的一个秘密共享方案$\prod $是线性的，当且仅当满足如下两个条件：</p>
<ul>
<li>每个参与者关于秘密值$s$的份额构成$\mathbb{Z}_{p}$上的一给向量；</li>
<li>存在一个秘密共享方案$\prod $的分享生成矩阵$M \in \mathbb{Z}_{p} ^ {l \times \theta}$，函数$\rho \left ( i \right )$将矩阵的第$i$行映射到一个$U$上的属性，即$\rho \left ( i \right ) \in U, \forall i \in \left [ l \right ]$。给定一个列向量$\overrightarrow{v}=\left ( s,r_2,…,r_{\theta} \right )$，其中$s \in \mathbb{Z}_{p}$是需要共享的秘密值，$r_2,…,r_{\theta}$在$\mathbb{Z}_{p}$上随机选取。$M\overrightarrow{v}$向量是根据秘密共享方案$\prod $的$l$份份额，第$i$份份额$\delta _i = \left ( Mv \right )_i$是属于属性$\rho \left ( i \right )$，即为$M$和$\overrightarrow{v}$的内积。</li>
</ul>
<p>线性秘密共享方案具有线性重构的特性。假设一个线性秘密共享方案$\prod $代表一个访问结构，令$A \in \mathbb{A} $表示一个授权的属性集合，索引集合$I \subset  \left \{ 1,…,l \right \}$定义为$I=\left \{ i:\rho \left ( i \right ) \in A \right \}$。根据线性重构的性质，则存在一系列常数的集合$\left \{ \omega_i \in \mathbb{Z}_p  \right \}_{i \in I}$，使得$s=\sum _{i \in I} \omega _i\delta _i$。而且这些常数能在多项式时间内找到。对于任何非授权的集合，找不到满足条件的一组常数。</p>
<h4 id="三种访问结构对比"><a href="#三种访问结构对比" class="headerlink" title="三种访问结构对比"></a>三种访问结构对比</h4><p>从访问结构的表达力上说，与门访问结构是比较差的，因为其是属性的与的关系，所以匹配的条件比较严格，由最初的二值属性（有或者没有）在一定程度上拓展了其表达力。访问控制树和线性秘密共享方案是可以等价的，描述的都是单调的访问结构（单调访问结构直观上理解就是，a的属性集合满足访问结构，而a有的属性b都有，那么b的属性集合必然也满足访问结构），能支持与门、或门以及其他门限，因此表达力强一些。文献<sup><a href="ref7">7</a></sup> 描述了由访问控制树如何转化为线性秘密共享的生成矩阵（只含有0,1和-1）。</p>
<p><span name="ref1">A. Sahai and B. Waters, “Fuzzy Identity-Based Encryption,” in <em>Proceedings of the 24th annual international conference on Theory and Applications of Cryptographic Techniques</em>, Arahus, Denmark, 2005, pp. 457–473.</span></p>
<p><span name="ref2">J. Bethencourt, A. Sahai, and B. Waters, “Ciphertext-Policy Attribute-Based Encryption,” in <em>IEEE Symposium on Security &amp; Privacy</em>, Oakland, USA, May 2007, pp. 321–334.</span></p>
<p><span name="ref3">V. Goyal, O. Pandey, A. Sahai, and B. Waters, “Attribute-Based Encryption for Fine-grained Access Control of Encrypted Data,” in <em>Proceedings of the 13th ACM Conference on Computer and Communications Security</em>, Alexandria, Virginia, USA, 2006, pp. 89–98.</span></p>
<p><span name="ref4">H. H. Krawczyk, “A high-performance secure Diffie–Hellman protocol,” in <em>Advances in Cryptology</em>. Berlin, Germany: Springer, 2005, pp. 1–62.</span></p>
<p><span name="ref5">A. Beimel, “Secure Schemes for Secret Sharing and Key Distribution,”PhD thesis, Israel Institute of Technology, Technion, Haifa, Israel, 1996.</span></p>
<p><span name="ref6">L. Cheung and C. Newport, “Provably Secure Ciphertext Policy ABE,” in <em>Proceedings of ACM Conference on Computer and Commmunications Security</em>, pp. 456-465, 2007.</span></p>
<p><span name="ref7">S. Ruj, A. Nayak and I. Stojmenovic, “DACC: Distributed Access Control in Clouds,” in <em>2011IEEE 10th International Conference on Trust, Security and Privacy in Computing and Communications</em>, Changsha, 2011, pp. 91-98.</span></p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>访问结构</tag>
      </tags>
  </entry>
  <entry>
    <title>随机化有关</title>
    <url>/2021/11/08/%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%9C%89%E5%85%B3/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文介绍随机化有关问题，包括打乱数组、rand 7生成rand 10、按权重随机选择、在圆内随机生成点、链表随机节点和随机数索引。</p>
<span id="more"></span>
<h4 id="打乱数组1"><a href="#打乱数组1" class="headerlink" title="打乱数组1"></a>打乱数组<sup><a href="ref1">1</a></sup></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组<code>nums</code> ，设计算法来打乱一个没有重复元素的数组。</p>
<p><strong>示例输入</strong>：<code>[3, 1, 2]</code></p>
<p><strong>示例输出</strong>：<code>[1, 2, 3]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapAt</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数</span></span><br><span class="line">            swapAt(i, randRange(i, array.length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rand-7生成rand-102"><a href="#rand-7生成rand-102" class="headerlink" title="rand 7生成rand 102"></a>rand 7生成rand 10<sup><a href="ref2">2</a></sup></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>已有方法 <code>rand7</code> 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 1 到 10 范围内的均匀随机整数。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先rand7()-1得到的数的集合为&#123;0,1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//再乘7后得到的集合为 &#123;0,7,14,21，28，35，42&#125;</span></span><br><span class="line"><span class="comment">//后面rand7()得到的集合&#123;1,2,3,4,5,6,7&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先得到一个数</span></span><br><span class="line">        <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">        <span class="comment">// 只要它还大于10，那就给我不断生成，因为我只要范围在1-10的，最后直接返回就可以了</span></span><br><span class="line">        <span class="comment">//拒绝采样</span></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="按权重随机选择3"><a href="#按权重随机选择3" class="headerlink" title="按权重随机选择3"></a>按权重随机选择<sup><a href="ref3">3</a></sup></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个 下标从<code>0</code>开始 的正整数数组<code>w</code> ，其中 <code>w[i]</code>代表第 <code>i</code>个下标的权重。</p>
<p>请你实现一个函数 <code>pickIndex</code> ，它可以 随机地 从范围<code>[0, w.length - 1]</code>内（含<code>0</code>和 <code>w.length - 1</code>）选出并返回一个下标。选取下标<code>i</code>的 概率 为<code>w[i] / sum(w)</code> 。</p>
<p><strong>示例输入</strong>：<br><code>[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]
[[[1,3]],[],[],[],[],[]]</code></p>
<p><strong>示例输出</strong>：<code>[null,1,1,1,1,0]</code></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] pre;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        pre=<span class="keyword">new</span> <span class="keyword">int</span>[w.length];</span><br><span class="line">        pre[<span class="number">0</span>]=w[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;w.length;i++)&#123;</span><br><span class="line">            pre[i]=pre[i-<span class="number">1</span>]+w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum=Arrays.stream(w).sum();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=(<span class="keyword">int</span>)(Math.random()*sum)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=pre.length;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre[mid]&lt;x)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在圆内随机生成点4"><a href="#在圆内随机生成点4" class="headerlink" title="在圆内随机生成点4"></a>在圆内随机生成点<sup><a href="ref4">4</a></sup></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 <code>randPoint</code> 。</p>
<p><strong>示例输入</strong>：<code>[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;][[1,0,0],[],[],[]]</code></p>
<p><strong>示例输出</strong>：<code>[null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</code></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> rad, xc, yc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center)</span> </span>&#123;</span><br><span class="line">        rad = radius;</span><br><span class="line">        xc = x_center;</span><br><span class="line">        yc = y_center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] randPoint() &#123;</span><br><span class="line">        <span class="keyword">double</span> x0 = xc - rad;</span><br><span class="line">        <span class="keyword">double</span> y0 = yc - rad;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> xg = x0 + Math.random() * rad * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> yg = y0 + Math.random() * rad * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (Math.sqrt(Math.pow((xg - xc) , <span class="number">2</span>) + Math.pow((yg - yc), <span class="number">2</span>)) &lt;= rad)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xg, yg&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表随机节点5"><a href="#链表随机节点5" class="headerlink" title="链表随机节点5"></a>链表随机节点<sup><a href="ref5">5</a></sup></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点<strong>被选的概率一样</strong>。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//蓄水池抽样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode head;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reserve = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="keyword">this</span>.random.nextInt(count)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==count)&#123;</span><br><span class="line">                reserve = cur.val;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reserve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="随机数索引6"><a href="#随机数索引6" class="headerlink" title="随机数索引6"></a>随机数索引<sup><a href="ref6">6</a></sup></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//蓄水池抽样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                <span class="comment">//计算同一个target的个数</span></span><br><span class="line">                n++;</span><br><span class="line">                <span class="comment">//我们以同一个数字的频数1/n的概率选出其中一个索引</span></span><br><span class="line">                <span class="keyword">if</span>(r.nextInt(n)+<span class="number">1</span> == n) index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/shuffle-an-array/">https://leetcode-cn.com/problems/shuffle-an-array/</a></span></p>
<p><span name="ref2"><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">https://leetcode-cn.com/problems/implement-rand10-using-rand7/</a></span></p>
<p><span name="ref3"><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">https://leetcode-cn.com/problems/random-pick-with-weight/</a></span></p>
<p><span name="ref4"><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/">https://leetcode-cn.com/problems/generate-random-point-in-a-circle/</a></span></p>
<p><span name="ref5"><a href="https://leetcode-cn.com/problems/linked-list-random-node/">https://leetcode-cn.com/problems/linked-list-random-node/</a></span></p>
<p><span name="ref6"><a href="https://leetcode-cn.com/problems/random-pick-index/">https://leetcode-cn.com/problems/random-pick-index/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>雾计算与属性基加密</title>
    <url>/2021/04/05/%E9%9B%BE%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h4 id="雾计算的概念"><a href="#雾计算的概念" class="headerlink" title="雾计算的概念"></a>雾计算的概念</h4><p>雾计算与云计算相对，是其在边缘网络上的拓展。</p>
<h4 id="云计算与雾计算的对比"><a href="#云计算与雾计算的对比" class="headerlink" title="云计算与雾计算的对比"></a>云计算与雾计算的对比</h4><p>云计算可以资源共享、弹性资源租用、按需购买，拥有海量存储和丰富的计算能力。由于其部署在互联网的中心，因此离日常中的终端（比如用户手机、智能穿戴设备等）较远，因此形象地称之为云计算（云高高在上，离地面较远）。<br><span id="more"></span><br>云计算虽能提供优质的计算、存储等服务，但网络边缘的数据传到云存储中心的链路通常很长，并且同一时间内用户数据传输很多需要很大的网络带宽。云服务器与终端较远会导致网络时延，因而不能满足实时性要求很高的应用场景。另外，云服务器是在网络中心，并不能感知传输到它的数据来源的地理分布，而且不支持移动性。</p>
<h4 id="雾计算的特点"><a href="#雾计算的特点" class="headerlink" title="雾计算的特点"></a>雾计算的特点</h4><p>针对上面的缺陷，雾计算便被提出。与云计算相比，雾计算有以下特点：</p>
<ul>
<li>位置感知、低延时。雾计算框架中的雾节点往往分布在边缘位置，能感知其所在范围内设备的位置，而且雾节点与终端设备的通信时延相比设备与云服务器的时延大大缩减，因而可以支持延时需求高的应用场景。</li>
<li>广泛地理分布。与中心化的云形成鲜明的对比，雾节点会根据连接网络中各个终端设备的地理分布，相应地广泛分布。</li>
<li>大规模终端节点。接入网络的终端设备除了像用户手机之类的智能设备外，还有各种各样的传感器，监测湿度、温度等多种物理量，这些设备呈现出低存储、低计算能力的特点，构成分布式的系统。由此整个网络中节点的规模空前巨大。</li>
<li>实时交互和无线接入。终端和雾节点的通信延时极低确保能实时交互，这能满足时延要求高的应用场景，比如自动驾驶等。终端和雾节点之间通过无线连接。</li>
<li>异质性和互操作性。雾节点可以以不同的形式呈现，应用于不同的环境。来自于终端的信息往往需要整合处理，因此需要跨域操作，节点间需要合作。</li>
<li>在线分析和云雾协作。雾节点能对来自终端的数据进行在线分析，并且可以和云数据中心进行交互。</li>
</ul>
<h4 id="云计算的应用场景"><a href="#云计算的应用场景" class="headerlink" title="云计算的应用场景"></a>云计算的应用场景</h4><ul>
<li>车联网。智能交通灯等智能设备监测交通实时状况，实现车辆与车辆、车辆与接入点、接入点与接入点之间的实时交互。</li>
<li>智能电网。在智能电网中，能量负载均衡应用可以在网络边缘设备上运行，基于能量需求，可用性和最低价格等因素可以自动地切换到像太阳能、风能 等可选择的能源。网络边缘的雾收集器处理智能传感器和设备生成的数据，并且向制动器发出控制命令。它们还要过滤在本地处理的数据，并将剩余的数据发送到更高层，用于可视化和实时事务分析的报告。</li>
<li>无线传感器和致动网络。雾设备制动器（雾计算服务器）可以通过创建闭环系统来控制系统，并且测量过程的稳定性和振荡行为。以此来弥补传统传感器需要额外施加物理动作实现相应功能打开。关闭等要求。</li>
<li>智能家居。各类传感器实时监测环境中的物理量，收集的数据交由雾节点协作处理，从而传递给系统进行智能决策。雾节点之间也可以协作，为更高级别的决策生成依据。</li>
</ul>
<h4 id="雾计算网络框架"><a href="#雾计算网络框架" class="headerlink" title="雾计算网络框架"></a>雾计算网络框架</h4><p>雾计算的网络框架是三层框架，第一层是智能终端层，该层可以是移动手机、各类传感器等，特点是存储。计算资源受限；第二层是雾计算节点层，该层具有适度的计算和存储资源；第三层是云数据中心，这一层具有海量存储和超强的计算能力。三层的位置关系为：第一层和第二层靠的近，第三层与第二层靠的很远。</p>
<h4 id="雾计算中的研究问题"><a href="#雾计算中的研究问题" class="headerlink" title="雾计算中的研究问题"></a>雾计算中的研究问题</h4><ul>
<li>计算卸载。计算卸载可以克服移动设备上的资源限制，因为一些计算密集型任务就应用的性 能而言可以从卸载中获益，从而节省计算资源和电池寿命。计算卸载考虑的是终端的计算资源受限，可以将复杂的计算卸载到雾节点服务器以及云服务器，但是如何运用好的卸载策略需要考虑计算能量、计算代价以及计算时延等。</li>
<li>边缘缓存。边缘缓存指的是将需要频繁访问的网络内容放在离用户较近、访问速度较快的 边缘网络设备中（也即雾设备）。边缘缓存技术的提出明显缓解了用户频繁请求云服务中心获取文件的压力。边缘缓存通常包含两个紧密相关的问题：缓存文件位置和缓存文件传递。文件缓存位置问题包括决定每一个缓存的位置和大小，选择数据库中的某一个文件放在某一个雾节点，并且如何下载文件到雾节点。缓存文件传递问题是如何发送文件给请求该文件的用户。边缘缓存考虑的是终端的存储资源受限，制定合理的边缘缓存策略使得终端可以迅速下载雾中数据，便于数据后续处理。</li>
</ul>
<h4 id="雾计算与属性基加密的关系"><a href="#雾计算与属性基加密的关系" class="headerlink" title="雾计算与属性基加密的关系"></a>雾计算与属性基加密的关系</h4><p>智能设备由于其存储和计算资源的局限性，总会想方设法解决对自己所有（或者所产生）数据的存储计算问题，并且希望访问控制的主动权掌握在自己手里。自然想到的解决办法是将将数据外包。和云计算类似，只不过雾计算在框架上增加了一个层次，即在网络的边缘增加大量的雾节点。云计算中，属性基加密方法是一个有前途的密码方案，可以提供细粒度的访问控制，终端自定义访问结构，终端将数据加密上传到云存储，其他用户只要满足访问结构便可以从云上下载并解密密文。在雾计算中，数据外包同样可以运用属性基加密的方式，提供细粒度的访问控制。只不过在雾计算中，终端设备可以将数据上传到雾节点或者云服务器，雾节点和云服务器可以进行服务上的交互。上传到雾中的数据可以直接被雾覆盖的其他终端或者用户所下载，相当于一个局部的概念；而上传到云中的数据可以被所有网络中的用户或者终端下载，相当于一个全局的概念。属性基加密运用到云计算上解决的问题，同样可以运用到雾计算中。</p>
]]></content>
      <categories>
        <category>属性基加密</category>
      </categories>
      <tags>
        <tag>属性基加密</tag>
        <tag>雾计算</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索有关</title>
    <url>/2021/10/19/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%9C%89%E5%85%B3/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>本文介绍广度优先搜索有关问题，包括树的层次遍历、完全平方数、01矩阵、公交线路、二维网格中探测环、最小体力消耗路径、节点间通路。深度优先搜索的过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。与深度优先搜素不同，广度优先搜索则从源节点开始，逐层次的地访问每一个节点，每个节点只访问一次。</p>
<span id="more"></span>
<h4 id="树的层次遍历1"><a href="#树的层次遍历1" class="headerlink" title="树的层次遍历1"></a>树的层次遍历<sup><a href="ref1">1</a></sup></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。<strong>示例输入</strong>：<code>[3,9,20,null,null,15,7]</code></p>
<p><strong>示例输出</strong>：<code>[[3],[9,20],[15,7]]</code></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.isEmpty() != <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> length = queue.size();</span><br><span class="line">            TreeNode tmp = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)&#123;</span><br><span class="line">                tmp = queue.poll();</span><br><span class="line">                level.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>) queue.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>) queue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="完全平方数2"><a href="#完全平方数2" class="headerlink" title="完全平方数2"></a>完全平方数<sup><a href="ref2">2</a></sup></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p><strong>示例输入</strong>：<code>n = 12</code></p>
<p><strong>示例输出</strong>：<code>3</code></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录访问过的节点值</span></span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    queue.offer(<span class="number">0</span>);</span><br><span class="line">    visited.add(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//树的第几层</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//每一层的节点数量</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        level++;</span><br><span class="line">        <span class="comment">//遍历当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//节点的值</span></span><br><span class="line">            <span class="keyword">int</span> digit = queue.poll();</span><br><span class="line">            <span class="comment">//访问当前节点的子节点，类比于二叉树的左右子节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">//子节点的值</span></span><br><span class="line">                <span class="keyword">int</span> nodeValue = digit + j * j;</span><br><span class="line">                <span class="comment">//nodeValue始终是完全平方数的和，当他等于n的</span></span><br><span class="line">                <span class="comment">//时候直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (nodeValue == n)</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                <span class="comment">//如果大于n，终止内层循环</span></span><br><span class="line">                <span class="keyword">if</span> (nodeValue &gt; n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(nodeValue)) &#123;</span><br><span class="line">                    queue.offer(nodeValue);</span><br><span class="line">                    visited.add(nodeValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="01矩阵3"><a href="#01矩阵3" class="headerlink" title="01矩阵3"></a>01矩阵<sup><a href="ref3">3</a></sup></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<p><strong>示例输入</strong>：<code>mat = [[0,0,0],[0,1,0],[0,0,0]]</code></p>
<p><strong>示例输出</strong>：<code>[[0,0,0],[0,1,0],[0,0,0]]</code></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">// 首先将所有的 0 都入队，并且将 1 的位置设置成 -1，表示该位置是 未被访问过的 1</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    matrix[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="comment">// 如果四邻域的点是 -1，表示这个点是未被访问过的 1</span></span><br><span class="line">                <span class="comment">// 所以这个点到 0 的距离就可以更新成 matrix[x][y] + 1。</span></span><br><span class="line">                <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n </span><br><span class="line">                        &amp;&amp; matrix[newX][newY] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    matrix[newX][newY] = matrix[x][y] + <span class="number">1</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;newX, newY&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span>[][] flag,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len=queue.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;len;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] cur=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(mat[cur[<span class="number">0</span>]][cur[<span class="number">1</span>]]==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">int</span>[][] dirs=&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">                <span class="comment">//res++;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:dirs)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(inArea(cur[<span class="number">0</span>]+dir[<span class="number">0</span>],cur[<span class="number">1</span>]+dir[<span class="number">1</span>],m,n) &amp;&amp;</span><br><span class="line">                    flag[cur[<span class="number">0</span>]+dir[<span class="number">0</span>]][cur[<span class="number">1</span>]+dir[<span class="number">1</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                        flag[cur[<span class="number">0</span>]+dir[<span class="number">0</span>]][cur[<span class="number">1</span>]+dir[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>]+dir[<span class="number">0</span>],cur[<span class="number">1</span>]+dir[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i&gt;=<span class="number">0</span>) &amp;&amp; (i&lt;m) &amp;&amp; (j&gt;=<span class="number">0</span>) &amp;&amp; (j&lt;n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="公交线路4"><a href="#公交线路4" class="headerlink" title="公交线路4"></a>公交线路<sup><a href="ref4">4</a></sup></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。</p>
<p>例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … 这样的车站路线行驶。<br>现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。</p>
<p>求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。</p>
<p><strong>示例输入</strong>：<code>routes = [[1,2,7],[3,6,7]], source = 1, target = 6</code></p>
<p><strong>示例输出</strong>：<code>2</code></p>
<p><strong>解释</strong>：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。</p>
<p><strong>示例输入</strong>：<code>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12</code></p>
<p><strong>示例输出</strong>：<code>-1</code></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="keyword">int</span>[][] routes, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source==target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=routes.length;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; s2b=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;routes[i].length;j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; list=s2b.getOrDefault(routes[i][j],<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                list.add(i);</span><br><span class="line">                s2b.put(routes[i][j],list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] flag=<span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">        queue.add(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=queue.size();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> cur=queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> b:s2b.get(cur))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag[b]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    flag[b]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> s:routes[b])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s==cur) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(s==target) <span class="keyword">return</span> count;</span><br><span class="line">                        <span class="keyword">else</span> queue.add(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二维网格中探测环5"><a href="#二维网格中探测环5" class="headerlink" title="二维网格中探测环5"></a>二维网格中探测环<sup><a href="ref5">5</a></sup></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个二维字符网格数组 grid ，大小为 m x n ，你需要检查 grid 中是否存在 相同值 形成的环。</p>
<p>一个环是一条开始和结束于同一个格子的长度 大于等于 4 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 相同的值 。</p>
<p>同时，你也不能回到上一次移动时所在的格子。比方说，环  (1, 1) -&gt; (1, 2) -&gt; (1, 1) 是不合法的，因为从 (1, 2) 移动到 (1, 1) 回到了上一次移动时的格子。</p>
<p>如果 grid 中有相同值形成的环，请你返回 true ，否则返回 false 。</p>
<p><strong>示例输入</strong>：<code>grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]</code></p>
<p><strong>示例输出</strong>：<code>true</code></p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsCycle</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(m * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!uf.findAndUnite(i * n + j, (i - <span class="number">1</span>) * n + j)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!uf.findAndUnite(i * n + j, i * n + j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> setCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        setCount = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : (parent[x] = findset(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --setCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findAndUnite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parentX = findset(x);</span><br><span class="line">        <span class="keyword">int</span> parentY = findset(y);</span><br><span class="line">        <span class="keyword">if</span> (parentX != parentY) &#123;</span><br><span class="line">            unite(parentX, parentY);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小体力消耗路径6"><a href="#最小体力消耗路径6" class="headerlink" title="最小体力消耗路径6"></a>最小体力消耗路径<sup><a href="ref6">6</a></sup></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row] [col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。</p>
<p>一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。</p>
<p>请你返回从左上角走到右下角的最小 体力消耗值 。</p>
<p><strong>示例输入</strong>：<code>heights = [[1,2,2],[3,8,2],[5,3,5]]</code></p>
<p><strong>示例输出</strong>：<code>2</code></p>
<p><strong>解释</strong>:路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heights.length, n = heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span>[][] dir = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : memo)</span><br><span class="line">            Arrays.fill(arr, Integer.MAX_VALUE);</span><br><span class="line">        memo[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//int[][] flag=new int[m][n];</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur / n, y = cur % n;</span><br><span class="line">            <span class="comment">//flag[x][y]=1;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] d : dir) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + d[<span class="number">0</span>], ny = y + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; m &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">int</span> effort = Math.max(memo[x][y], Math.abs(heights[nx][ny] - heights[x][y]));</span><br><span class="line">                    <span class="keyword">if</span>(effort &gt;= memo[nx][ny])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    memo[nx][ny] = effort;</span><br><span class="line">                    queue.offer(nx * n + ny);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath1</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = mat.length;</span><br><span class="line">        <span class="keyword">int</span> N = mat[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">                    edges.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                            Math.abs(mat[i][j + <span class="number">1</span>] - mat[i][j]),</span><br><span class="line">                            i * N + j,</span><br><span class="line">                            i * N + j + <span class="number">1</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; M) &#123;</span><br><span class="line">                    edges.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                            Math.abs(mat[i + <span class="number">1</span>][j] - mat[i][j]),</span><br><span class="line">                            i * N + j,</span><br><span class="line">                            (i + <span class="number">1</span>) * N + j</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(edges, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(M * N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            uf.union(edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (uf.find(<span class="number">0</span>) == uf.find(M * N - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;      <span class="comment">// 连通分量个数</span></span><br><span class="line">        <span class="keyword">int</span>[] parent;   <span class="comment">// 节点i的父节点是parent[i]</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = N;         <span class="comment">// n为图的节点总数</span></span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                parent[i] = i;      <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rootX] = rootY;          <span class="comment">// x成为y的子树</span></span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="节点间通路7"><a href="#节点间通路7" class="headerlink" title="节点间通路7"></a>节点间通路<sup><a href="ref7">7</a></sup></h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>
<p><strong>示例输入</strong>：<code>n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2</code></p>
<p><strong>示例输出</strong>：<code>true</code></p>
<p><strong>示例输入</strong>：<code>n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4</code></p>
<p><strong>示例输出</strong>：<code>true</code></p>
<h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.length;i++)&#123;            </span><br><span class="line">            list.get(graph[i][<span class="number">0</span>]).add(graph[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        queue.add(start);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=queue.poll();</span><br><span class="line">            flag[tmp]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp==target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(Integer o:list.get(tmp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag[o])&#123;</span><br><span class="line">                    queue.add(o);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><span name="ref1"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a></span></p>
<p><span name="ref2"><a href="https://leetcode-cn.com/problems/perfect-squares">https://leetcode-cn.com/problems/perfect-squares</a></span></p>
<p><span name="ref3"><a href="https://leetcode-cn.com/problems/01-matrix">https://leetcode-cn.com/problems/01-matrix</a></span></p>
<p><span name="ref4"><a href="https://leetcode-cn.com/problems/bus-routes">https://leetcode-cn.com/problems/bus-routes</a></span></p>
<p><span name="ref5"><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid">https://leetcode-cn.com/problems/detect-cycles-in-2d-grid</a></span></p>
<p><span name="ref6"><a href="https://leetcode-cn.com/problems/path-with-minimum-effort">https://leetcode-cn.com/problems/path-with-minimum-effort</a></span></p>
<p><span name="ref7"><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/">https://leetcode-cn.com/problems/route-between-nodes-lcci/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>广度优先搜索</category>
      </categories>
      <tags>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
</search>
